<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="雁渡寒潭 风吹疏竹">
<meta property="og:url" content="http://slamke.github.io/page/10/index.html">
<meta property="og:site_name" content="雁渡寒潭 风吹疏竹">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雁渡寒潭 风吹疏竹">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://slamke.github.io/page/10/"/>





  <title>雁渡寒潭 风吹疏竹</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雁渡寒潭 风吹疏竹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">教练，我想打篮球</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/AkkaCluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/AkkaCluster/" itemprop="url">AkkaCluster</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T15:14:20+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Akka集群原理"><a href="#Akka集群原理" class="headerlink" title="Akka集群原理"></a>Akka集群原理</h2><p>Akka集群支持去中心化的基于P2P的集群服务，没有单点故障（SPOF）问题，它主要是通过Gossip协议来实现。对于集群成员的状态，Akka提供了一种故障检测机制，能够自动发现出现故障而离开集群的成员节点，通过事件驱动的方式，将状态传播到整个集群的其它成员节点。</p>
<h3 id="1-状态转移与故障检测"><a href="#1-状态转移与故障检测" class="headerlink" title="1. 状态转移与故障检测"></a>1. 状态转移与故障检测</h3><p>Akka内部为集群成员定义了一组有限状态（6种状态），并给出了一个状态转移矩阵，代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span>[cluster] <span class="keyword">val</span> allowedTransitions: <span class="type">Map</span>[<span class="type">MemberStatus</span>, <span class="type">Set</span>[<span class="type">MemberStatus</span>]] =</span><br><span class="line">    <span class="type">Map</span>(</span><br><span class="line">      <span class="type">Joining</span> -&gt; <span class="type">Set</span>(<span class="type">Up</span>, <span class="type">Down</span>, <span class="type">Removed</span>),</span><br><span class="line">      <span class="type">Up</span> -&gt; <span class="type">Set</span>(<span class="type">Leaving</span>, <span class="type">Down</span>, <span class="type">Removed</span>),</span><br><span class="line">      <span class="type">Leaving</span> -&gt; <span class="type">Set</span>(<span class="type">Exiting</span>, <span class="type">Down</span>, <span class="type">Removed</span>),</span><br><span class="line">      <span class="type">Down</span> -&gt; <span class="type">Set</span>(<span class="type">Removed</span>),</span><br><span class="line">      <span class="type">Exiting</span> -&gt; <span class="type">Set</span>(<span class="type">Removed</span>, <span class="type">Down</span>),</span><br><span class="line">      <span class="type">Removed</span> -&gt; <span class="type">Set</span>.empty[<span class="type">MemberStatus</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Akka集群中的每个成员节点，都有可能处于上面的一种状态，在发生某些事件以后，会发生状态转移。需要注意的是，除了Down和Removed状态以外，节点处于其它任何一个状态时都有可能变成Down状态，即节点故障而无法提供服务，而在变成Down状态之前有一个虚拟的Unreachable状态，因为在Gossip收敛过程中，是无法到达或者经由Unreachable状态的节点，这个状态是由Akka实现的故障探测器（Failure Detector）来检测到的。处于Down状态的节点如果想要再次加入Akka集群，需要重新启动，并进入Joining状态，然后才能进行后续状态的转移变化。Akka集群成员节点状态及其转移情况，如下图所示：<br><img src="https://github.com/slamke/image/blob/master/akka/cluster.png?raw=true" alt=""><br>在Akka中，集群中每一个成员节点M会被集群中的其他另一组节点（默认是5个）G监控，这一组节点G并不是整个集群中的其他所有节点，只是整个集群全部节点的一个子集，组G中的节点会检测节点M是否处于Unreachable状态，这是通过发送心跳来确认节点M是否可达，如果不可达则组G中的节点会将节点M的Unreachable状态向集群中组G之外的其它节点传播，最终使得集群中的每个成员节点都知道节点M故障。</p>
<h3 id="2-Akka事件集合"><a href="#2-Akka事件集合" class="headerlink" title="2.Akka事件集合"></a>2.Akka事件集合</h3><p>节点状态发生转移会触发某个事件，我们可以根据不同类型的事件来进行相应的处理，为了能够详细捕获到各种事件，我们先看一下Akka定义的事件集合，如图所示：<br><img src="https://github.com/slamke/image/blob/master/akka/cluster_events.png?raw=true" alt=""></p>
<h3 id="3-Akka成员角色（Node-Role）"><a href="#3-Akka成员角色（Node-Role）" class="headerlink" title="3.Akka成员角色（Node Role）"></a>3.Akka成员角色（Node Role）</h3><p>Akka支持在每个成员节点加入集群的时候，设置成员自己的角色。通过角色划分，可以将使用Akka集群处理业务的系统划分为多个处理逻辑独立的子系统，每个子系统处理自己的业务逻辑，而且，划分得到的多个子系统都处于一个统一的Akka集群中。因此，每个子系统也具备了Akka集群所具有的特性，如故障检测、状态转移、状态传播等等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/有类型Actor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/有类型Actor/" itemprop="url">有类型Actor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T13:47:30+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="有类型Actor"><a href="#有类型Actor" class="headerlink" title="有类型Actor"></a>有类型Actor</h1><ul>
<li>通过接口明确actor可以接收的消息目标和行为。</li>
</ul>
<p>TypedActor是Akka基于Active对象（Active Object）设计模式的一个实现，关于Active对象模式，可以看维基百科的定义：<br>Active对象模式解耦了在一个对象上执行方法和调用方法的逻辑，执行方法和调用方法分别在各自的线程执行上下文中。该模式的目标是通过使用异步方法调用和一个调度器来处理请求，从而实现并行计算处理，该模式由6个元素组成：</p>
<ul>
<li>一个Proxy对象，提供一个面向客户端的接口和一组公共的方法</li>
<li>一个接口，定义了请求一个Active对象上的方法的集合</li>
<li>一个来自客户端请求的列表</li>
<li>一个调度器，确定下一次处理哪一个请求</li>
<li>Active对象上方法的实现</li>
<li>一个回调或者变量，供客户端接收请求被处理后的结果<br>通过前面对Actor的了解，我们知道Actor更适用于在Akka的Actor系统之间来实现并行计算处理，而TypedActor适用于桥接Actor系统和非Actor系统。TypedActor是基于JDK的Proxy来实现的，与Actor不同的是，Actor一次处理一个消息，而TypedActor一次处理一个调用（Call）。关于更多关于TypedActor，可以查看Akka文档。</li>
</ul>
<p>有类型Actor由两 “部分” 组成, <strong><em>一个公开的接口和一个实现,</em></strong> 对普通actor来说，你拥有一个外部API（公开接口的实例）来将方法调用异步地委托给其实现的私有实例。</p>
<p>有类型Actor相对于普通Actor的优势在于有类型Actor拥有静态的契约，你不需要定义你自己的消息；它的劣势在于对你能做什么和不能做什么进行了一些限制，即你不能使用become/unbecome。</p>
<p>有类型Actor是使用JDK Proxies实现的，JDK Proxies提供了非常简单的api来拦截方法调用。</p>
<blockquote>
<p>注意<br>和普通Akka actor一样，有类型actor一次也只处理一个消息。</p>
</blockquote>
<h2 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h2><p>在创建第一个有类型Actor之前，我们先了解一下我们手上可供使用的工具，它位于akka.actor.TypedActor中。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">TypedActor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回有类型actor扩展</span></span><br><span class="line"><span class="keyword">val</span> extension = <span class="type">TypedActor</span>(system) <span class="comment">//system是一个Actor系统实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个引用是否是有类型actor代理</span></span><br><span class="line"><span class="type">TypedActor</span>(system).isTypedActor(someReference)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个外部有类型actor代理所代表的Akka actor</span></span><br><span class="line"><span class="type">TypedActor</span>(system).getActorRefFor(someReference)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的ActorContext,</span></span><br><span class="line"><span class="comment">// 此方法仅在一个TypedActor 实现的方法中有效</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="type">ActorContext</span> = <span class="type">TypedActor</span>.context</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前有类型actor的外部代理,</span></span><br><span class="line"><span class="comment">// 此方法仅在一个TypedActor 实现的方法中有效</span></span><br><span class="line"><span class="keyword">val</span> s: <span class="type">Squarer</span> = <span class="type">TypedActor</span>.self[<span class="type">Squarer</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个有类型Actor扩展的上下文实例</span></span><br><span class="line"><span class="comment">//这意味着如果你用它创建其它的有类型actor，它们会成为当前有类型actor的子actor</span></span><br><span class="line"><span class="type">TypedActor</span>(<span class="type">TypedActor</span>.context)</span><br></pre></td></tr></table></figure></p>
<h2 id="创建有类型Actor"><a href="#创建有类型Actor" class="headerlink" title="创建有类型Actor"></a>创建有类型Actor</h2><p>要创建有类型Actor，需要一个或多个接口，和一个实现。<br>创建我们的Squarer的有类型actor实例的最简单方法是：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mySquarer: <span class="type">Squarer</span> =</span><br><span class="line">  <span class="type">TypedActor</span>(system).typedActorOf(<span class="type">TypedProps</span>[<span class="type">SquarerImpl</span>]())</span><br></pre></td></tr></table></figure></p>
<p>第一个类型是代理的类型，第二个类型是实现的类型。如果要调用某特定的构造方法要这样做：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> otherSquarer: <span class="type">Squarer</span> =</span><br><span class="line">  <span class="type">TypedActor</span>(system).typedActorOf(<span class="type">TypedProps</span>(classOf[<span class="type">Squarer</span>],</span><br><span class="line">    <span class="keyword">new</span> <span class="type">SquarerImpl</span>(<span class="string">"foo"</span>)), <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure></p>
<p>由于你提供了一个 Props, 你可以指定使用哪个派发器, 缺省的超时时间等。</p>
<p>方法派发语义</p>
<h3 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回:"></a>方法返回:</h3><ul>
<li>Unit 会以 fire-and-forget语义进行派发，与ActorRef.tell完全一致。</li>
<li>akka.dispatch.Future[_] 会以 send-request-reply语义进行派发，与 ActorRef.ask完全一致。</li>
<li>scala.Option[<em>]会以send-request-reply语义派发，但是会阻塞等待应答, 如果在超时时限内没有应答则返回scala.None，否则返回包含结果的scala.Some[</em>]。在这个调用中发生的异常将被重新抛出。</li>
<li>任何其它类型的值将以send-request-reply语义进行派发，但会阻塞地等待应答, 如果超时会抛出java.util.concurrent.TimeoutException，如果发生异常则将异常重新抛出。</li>
</ul>
<h3 id="终止有类型Actor"><a href="#终止有类型Actor" class="headerlink" title="终止有类型Actor"></a>终止有类型Actor</h3><p>由于有类型actor底层还是Akka actor，所以在不需要的时候要终止它。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TypedActor</span>(system).stop(mySquarer)</span><br><span class="line">这将会尽快地异步终止与指定的代理关联的有类型<span class="type">Actor</span>。</span><br><span class="line"></span><br><span class="line"><span class="type">TypedActor</span>(system).poisonPill(otherSquarer)</span><br><span class="line">这将会在有类型actor完成所有入队的调用后异步地终止它。</span><br></pre></td></tr></table></figure></p>
<h3 id="有类型Actor监管树"><a href="#有类型Actor监管树" class="headerlink" title="有类型Actor监管树"></a>有类型Actor监管树</h3><p>你可以通过传入一个ActorContext来获得有类型Actor上下文，所以你可以对它调用typedActorOf(..)来创建有类型子actor。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inside your Typed Actor</span></span><br><span class="line"><span class="keyword">val</span> childSquarer: <span class="type">Squarer</span> =</span><br><span class="line">  <span class="type">TypedActor</span>(<span class="type">TypedActor</span>.context).typedActorOf(<span class="type">TypedProps</span>[<span class="type">SquarerImpl</span>]())</span><br><span class="line"><span class="comment">//Use "childSquarer" as a Squarer</span></span><br><span class="line">通过将<span class="type">ActorContext</span>作为参数传给<span class="type">TypedActor</span>.get(…)，也可以为普通的<span class="type">Akka</span> actor创建有类型子actor。</span><br></pre></td></tr></table></figure></p>
<h3 id="监管策略"><a href="#监管策略" class="headerlink" title="监管策略"></a>监管策略</h3><p>通过让你的有类型Actor的具体实现类实现TypedActor.Supervisor方法，你可以定义用来监管子actor的策略，就像监管与监控 和容错(Scala)所描述的。</p>
<h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>通过使你的有类型actor实现类实现以下方法:</p>
<ul>
<li>TypedActor.PreStart</li>
<li>TypedActor.PostStop</li>
<li>TypedActor.PreRestart</li>
<li>TypedActor.PostRestart<br>你可以hook进有类型actor的整个生命周期。</li>
</ul>
<h3 id="接收任意消息"><a href="#接收任意消息" class="headerlink" title="接收任意消息"></a>接收任意消息</h3><p>如果你的有类型actor的实现类扩展了akka.actor.TypedActor.Receiver，所有非方法调用MethodCall的消息会被传给onReceive方法.</p>
<p>这使你能够对DeathWatch的Terminated消息及其它类型的消息进行处理，例如，与无类型actor进行交互的场合。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/Akka邮箱-路由器-调度器关键点说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/Akka邮箱-路由器-调度器关键点说明/" itemprop="url">Akka邮箱&路由器&调度器关键点说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:47:40+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Akkay邮箱-amp-路由器-amp-调度器关键点说明"><a href="#Akkay邮箱-amp-路由器-amp-调度器关键点说明" class="headerlink" title="Akkay邮箱&amp;路由器&amp;调度器关键点说明"></a>Akkay邮箱&amp;路由器&amp;调度器关键点说明</h1><p>Akka 无法保证消息将被传送到目的地。这种无保证传送背后的哲学原理是 Akka 的核心原理之一。<br>Akka 可以 保证消息最多传送一次，而且绝不会无序地收到从一个 actor 实例发送到另一个 actor 实例的消息。</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>Akka MessageDispatcher是维持 Akka Actor “运作”的部分, 可以说它是整个机器的引擎。所有的MessageDispatcher实现也同时也是一个ExecutionContext</p>
<h3 id="缺省派发器"><a href="#缺省派发器" class="headerlink" title="缺省派发器"></a>缺省派发器</h3><p>在没有为Actor作配置的情况下，每一个ActorSystem将有一个缺省的派发器。该缺省派发器可以被配置，默认是使用指定的default-executor的一个Dispatcher。如果一个ActorSystem是使用传入的ExecutionContext创建的，则该ExecutionContext将被用作所有派发器的默认执行器（“executor”）。如果没有给定ExecutionContext，则会回退使用akka.actor.default-dispatcher.default-executor.fallback指定的执行器。缺省情况下是使用“fork-join-executor”，它在大多数情况下拥有非常好的性能。</p>
<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>一个Akka Mailbox保存发往某个Actor的消息。通常每个Actor都拥有自己的邮箱，但也有例外，例如使用BalancingPool的所有路由子(routee)共享同一个邮箱实例。</p>
<h3 id="为actor指定一个消息队列类型"><a href="#为actor指定一个消息队列类型" class="headerlink" title="为actor指定一个消息队列类型"></a>为actor指定一个消息队列类型</h3><p>为某个特定类型的actor指定一个特定类型的消息队列是有可能的，只要通过actor扩展RequiresMessageQueue参数化特质即可。下面是一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.dispatch.<span class="type">RequiresMessageQueue</span></span><br><span class="line"><span class="keyword">import</span> akka.dispatch.<span class="type">BoundedMessageQueueSemantics</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBoundedActor</span> <span class="keyword">extends</span> <span class="title">MyActor</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">RequiresMessageQueue</span>[<span class="type">BoundedMessageQueueSemantics</span>]</span></span><br><span class="line"><span class="class"><span class="title">RequiresMessageQueue特质的类型参数需要映射到配置中的邮箱，像这样：</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">bounded-mailbox</span> </span>&#123;</span><br><span class="line">  mailbox-<span class="class"><span class="keyword">type</span> </span>= <span class="string">"akka.dispatch.BoundedMailbox"</span></span><br><span class="line">  mailbox-capacity = <span class="number">1000</span></span><br><span class="line">  mailbox-push-timeout-time = <span class="number">10</span>s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">akka.actor.mailbox.requirements &#123;</span><br><span class="line">  <span class="string">"akka.dispatch.BoundedMessageQueueSemantics"</span> = bounded-mailbox</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="如何选择邮箱类型"><a href="#如何选择邮箱类型" class="headerlink" title="如何选择邮箱类型"></a>如何选择邮箱类型</h3><p>当一个actor创建时，ActorRefProvider首先确定将执行它的调度器。然后，邮箱确定如下：</p>
<ol>
<li>如果actor的部署配置节包含mailbox键，则其描述邮箱类型将被使用。</li>
<li>如果actor的Props包含邮箱选择——即它调用了withMailbox——则其描述邮箱类型将被使用。</li>
<li>如果调度器的配置节包含mailbox-type键，则该节内容将用于配置邮箱类型。</li>
<li>如果该actor需要邮箱类型，如上文所述，然后该约束的映射将用于确定使用的邮箱类型；如果不能满足调度器的约束——如果有的话——将继续替换尝试。</li>
<li>如果调度器需要一个邮箱类型，如上文所述，则该约束的映射将被用来确定要使用的邮箱类型。</li>
<li>将使用默认邮箱akka.actor.default-mailbox。</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>消息可以通过路由器发送，以便有效地将它们路由到目的actor，称为其routee。一个Router可以在actor内部或外部使用，并且你可以自己管理routee或使用有配置功能的自我包含的路由actor。</p>
<p>为了创建路由器，设置指定数量的rountee,需要以下信息<br>-rounter类型和routee实例的数量<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorRef</span> masterAct = system.actorOf(<span class="type">Props</span>.create(<span class="type">MasterActor</span>.<span class="keyword">class</span>).withRouter(<span class="keyword">new</span> <span class="type">RoundRobinPool</span>(<span class="number">5</span>)),<span class="string">"RounterActor"</span>);</span><br></pre></td></tr></table></figure></p>
<p>定义了一个Actor,通过实例化一个路由器实例,这里是RoundRobin，它的构造函数接受一个参数，表示创建rountees的数量.</p>
<p>一个简单的路由器</p>
<p>下面的示例阐释如何使用Router和在actor内管理routee。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.routing.<span class="type">ActorRefRoutee</span></span><br><span class="line"><span class="keyword">import</span> akka.routing.<span class="type">Router</span></span><br><span class="line"><span class="keyword">import</span> akka.routing.<span class="type">RoundRobinRoutingLogic</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> router = &#123;</span><br><span class="line">    <span class="keyword">val</span> routees = <span class="type">Vector</span>.fill(<span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> r = context.actorOf(<span class="type">Props</span>[<span class="type">Worker</span>])</span><br><span class="line">      context watch r</span><br><span class="line">      <span class="type">ActorRefRoutee</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Router</span>(<span class="type">RoundRobinRoutingLogic</span>(), routees)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> w: <span class="type">Work</span> =&gt;</span><br><span class="line">      router.route(w, sender())</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(a) =&gt;</span><br><span class="line">      router = router.removeRoutee(a)</span><br><span class="line">      <span class="keyword">val</span> r = context.actorOf(<span class="type">Props</span>[<span class="type">Worker</span>])</span><br><span class="line">      context watch r</span><br><span class="line">      router = router.addRoutee(r)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Akka自带的路由逻辑如下：</p>
<ul>
<li>akka.routing.RoundRobinRoutingLogic</li>
<li>akka.routing.RandomRoutingLogic</li>
<li>akka.routing.SmallestMailboxRoutingLogic</li>
<li>akka.routing.BroadcastRoutingLogic</li>
<li>akka.routing.ScatterGatherFirstCompletedRoutingLogic</li>
<li>akka.routing.TailChoppingRoutingLogic</li>
<li>akka.routing.ConsistentHashingRoutingLogic</li>
</ul>
<p>Router是不可变的，而RoutingLogic是线程安全的；意味着他们也可以在actor外部使用。<br>路由actor是一种特殊的类型-RounterActorRef。RounterActorRef不是利用存储转发的机制，他直接路由消息到Rountee的邮箱，而不是到Router的邮箱，当routee答复路由消息时，回复将发送到原始发件人，而不是路由actor。</p>
<blockquote>
<p>注意<br>一般情况下，任何发送到路由器的消息将被向前发送到它的routee，但有一个例外。特别地广播消息将发送到路由器下所有的routee</p>
</blockquote>
<h3 id="一个路由actor"><a href="#一个路由actor" class="headerlink" title="一个路由actor"></a>一个路由actor</h3><p>一个路由器也可以被创建为一个自包含的actor，来管理routee，载入路由逻辑和其他配置设置。</p>
<p>注意:   路由器actor相当于是透明的<br>路由器也是子actor的监管者。路由器的默认策略是总是上溯，所以错误会传递给路由器的监管者处理。<br>注意路由器的监管者会将错误当做路由器的错位，因此会重启路由器，并将导致他的孩子全部重启。<br>如果路由器池的子actor终止，池路由器不会自动产生一个新的actor。在池路由器所有子actor都终止的事件中，路由器将终止本身，除非它是一个动态的路由器，例如使用了大小调整。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/AkkaRemote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/AkkaRemote/" itemprop="url">AkkaRemote</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:40:53+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Akka远程"><a href="#Akka远程" class="headerlink" title="Akka远程"></a>Akka远程</h2><p>Akka remoting是按照端到端（peer-to-peer）对等通信的方式设计的</p>
<h2 id="远程交互的类型"><a href="#远程交互的类型" class="headerlink" title="远程交互的类型"></a>远程交互的类型</h2><p>Akka 远程调用有两种方式:</p>
<ul>
<li>查找 : 使用actorSelection(path)在远程主机上查找一个actor</li>
<li>创建 : 使用actorOf(Props(…), actorName)在远程主机上创建一个actor</li>
</ul>
<h3 id="查找远程-Actors"><a href="#查找远程-Actors" class="headerlink" title="查找远程 Actors"></a>查找远程 Actors</h3><p>actorSelection(path)会获得远程结点上一个Actor的ActorSelection, 例如:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> selection =</span><br><span class="line">  context.actorSelection(<span class="string">"akka.tcp://actorSystemName@10.0.0.1:2552/user/actorName"</span>)</span><br><span class="line">可以看到以下模式被用来在远程结点上查找一个actor:</span><br><span class="line"></span><br><span class="line">akka.&lt;protocol&gt;:<span class="comment">//&lt;actor system&gt;@&lt;hostname&gt;:&lt;port&gt;/&lt;actor path&gt;</span></span><br><span class="line">一旦得到了actor的selection，你就可以像与本地actor通讯一样与它进行通迅, 例如:</span><br><span class="line"></span><br><span class="line">selection ! <span class="string">"Pretty awesome feature"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="用代码进行远程部署"><a href="#用代码进行远程部署" class="headerlink" title="用代码进行远程部署"></a>用代码进行远程部署</h3><p>要允许动态部署系统，也可以在用来创建actor的Props中包含deployment配置 : 这一部分信息与配置文件中的deployment部分是等价的, 如果两者都有，则外部配置拥有更高的优先级.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">加入这些<span class="keyword">import</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Props</span>, <span class="type">Deploy</span>, <span class="type">Address</span>, <span class="type">AddressFromURIString</span> &#125;</span><br><span class="line"><span class="keyword">import</span> akka.remote.<span class="type">RemoteScope</span></span><br><span class="line">和一个像这样的远程地址:</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> one = <span class="type">AddressFromURIString</span>(<span class="string">"akka.tcp://sys@host:1234"</span>)</span><br><span class="line"><span class="keyword">val</span> two = <span class="type">Address</span>(<span class="string">"akka.tcp"</span>, <span class="string">"sys"</span>, <span class="string">"host"</span>, <span class="number">1234</span>) <span class="comment">// this gives the same</span></span><br><span class="line">你可以像这样建议系统在此远程结点上创建一个子actor:</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ref = system.actorOf(<span class="type">Props</span>[<span class="type">SampleActor</span>].</span><br><span class="line">  withDeploy(<span class="type">Deploy</span>(scope = <span class="type">RemoteScope</span>(address))))</span><br></pre></td></tr></table></figure>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对actor使用远程调用时，你必须保证这些actor所使用的props和messages是可序列化的. 如果不能保证会导致系统产生意料之外的行为.<br>配置</p>
<ol>
<li><p>为了让 Akka 知道对什么任务使用哪个Serializer, 你需要编辑你的 配置文件, 在 “akka.actor.serializers”一节将名称绑定为akka.serialization.Serializer的实现</p>
</li>
<li><p>在将名称与Serializer的不同实现绑定后，你需要指定哪些类的序列化使用哪种Serializer, 这部分配置写在“akka.actor.serialization-bindings”一节中:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    serializers &#123;</span><br><span class="line">      java = "akka.serialization.JavaSerializer"</span><br><span class="line">      proto = "akka.remote.serialization.ProtobufSerializer"</span><br><span class="line">      myown = "docs.serialization.MyOwnSerializer"</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialization-bindings &#123;</span><br><span class="line">      "java.lang.String" = java</span><br><span class="line">      "docs.serialization.Customer" = java</span><br><span class="line">      "com.google.protobuf.Message" = proto</span><br><span class="line">      "docs.serialization.MyOwnSerializable" = myown</span><br><span class="line">      "java.lang.Boolean" = myown</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="自定义-创建新的-Serializer"><a href="#自定义-创建新的-Serializer" class="headerlink" title="自定义 创建新的 Serializer"></a>自定义 创建新的 Serializer</h4><p>首先你需要为你的 Serializer 写一个类定义，像这样:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">ActorRef</span>, <span class="type">ActorSystem</span> &#125;</span><br><span class="line"><span class="keyword">import</span> akka.serialization._</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.<span class="type">ConfigFactory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnSerializer</span> <span class="keyword">extends</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is whether "fromBinary" requires a "clazz" or not</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">includeManifest</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick a unique identifier for your Serializer,</span></span><br><span class="line">  <span class="comment">// you've got a couple of billions to choose from,</span></span><br><span class="line">  <span class="comment">// 0 - 16 is reserved by Akka itself</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">identifier</span> </span>= <span class="number">1234567</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// "toBinary" serializes the given object to an Array of Bytes</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toBinary</span></span>(obj: <span class="type">AnyRef</span>): <span class="type">Array</span>[<span class="type">Byte</span>] = &#123;</span><br><span class="line">    <span class="comment">// Put the code that serializes the object here</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "fromBinary" deserializes the given array,</span></span><br><span class="line">  <span class="comment">// using the type hint (if any, see "includeManifest" above)</span></span><br><span class="line">  <span class="comment">// into the optionally provided classLoader.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fromBinary</span></span>(bytes: <span class="type">Array</span>[<span class="type">Byte</span>],</span><br><span class="line">                 clazz: <span class="type">Option</span>[<span class="type">Class</span>[_]]): <span class="type">AnyRef</span> = &#123;</span><br><span class="line">    <span class="comment">// Put your code that deserializes here</span></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="远程事件"><a href="#远程事件" class="headerlink" title="远程事件"></a>远程事件</h3><p>可以监听Akka远程调用中发生的事件，也可以订阅/取消订阅这些事情，你只需要在ActorSystem.eventStream中为下面所列出类型的事件注册监听器.</p>
<blockquote>
<p>注意<br>若要订阅任意远程事件，订阅RemotingLifecycleEvent。若要订阅只涉及链接的生命周期的事件，请订阅akka.remote.AssociationEvent。</p>
</blockquote>
<blockquote>
<p>注意<br>使用”链接”而不是”连接”一词，反映了远程处理子系统可能使用无连接传输，但链接类似于运输层连接，来维持点到点之间的Akka协议。</p>
</blockquote>
<h3 id="远程安全"><a href="#远程安全" class="headerlink" title="远程安全"></a>远程安全</h3><p>Akka提供了几种方式来加强远程节点（客户端/服务器）之间的安全：</p>
<ul>
<li>不受信任的模式</li>
<li>安全 Cookie 握手</li>
</ul>
<ol>
<li>配置为不受信任模式的系统通过远程处理层传入的以下操作将被忽略：<ul>
<li>远程部署 （这也意味着没有远程监控）</li>
<li>远程DeathWatch</li>
<li>system.stop(), PoisonPill, Kill</li>
<li>发送任何继承自PossiblyHarmful标记接口的消息，包括Terminated</li>
<li>通过actor selection发送的消息，除非目标定义在trusted-selection-paths中。</li>
</ul>
</li>
<li>安全 Cookie 握手<br>Akka远程处理还允许你指定一个安全cookie，它将被交换并确保在客户端和服务器之间的连接握手中是相同的。如果他们不相同，则客户端将被拒绝连接到服务器。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/Akka的监管和监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/Akka的监管和监控/" itemprop="url">Akka的监管和监控</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:33:13+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Akka的监管和监控"><a href="#Akka的监管和监控" class="headerlink" title="Akka的监管和监控"></a>Akka的监管和监控</h1><h2 id="监管和监控"><a href="#监管和监控" class="headerlink" title="监管和监控"></a>监管和监控</h2><p>在 Actor 系统 中说过，监管描述的是actor之间的依赖关系：监管者将任务委托给下属，并相应地对下属的失败状况进行响应。当一个下属出现了失败（即抛出一个异常），它自己会将自己和自己所有的下属挂起，然后向自己的监管者发送一个提示失败的消息。基于所监管的工作的性质和失败的性质，监管者可以有4种基本选择：</p>
<ol>
<li>恢复下属，保持下属当前积累的内部状态</li>
<li>重启下属，清除下属的内部状态</li>
<li>永久地停止下属</li>
<li>升级失败（沿监管树向上传递失败），由此失败自己</li>
</ol>
<blockquote>
<p>警告<br>监管相关的父-子沟通，使用了特殊的系统消息及其固有的邮箱，从而和用户消息隔离开来。这意味着，监管相关的事件相对于普通的消息没有确定的顺序关系。在一般情况下，用户不能影响正常消息和失败通知的顺序。</p>
</blockquote>
<h3 id="顶级监管者"><a href="#顶级监管者" class="headerlink" title="顶级监管者"></a>顶级监管者</h3><p><img src="http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/chapter2/guardians.png" alt="enter image description here"></p>
<p>一个actor系统在其创建过程中至少要启动三个actor，如上图所示。</p>
<ul>
<li>/user: 守护Actor</li>
</ul>
<p>这个名为”/user”的守护者，作为所有用户创建actor的父actor，可能是需要打交道最多的。使用system.actorOf()创建的actor都是其子actor。</p>
<ul>
<li>/system: 系统守护者</li>
</ul>
<p>这个特殊的守护者被引入，是为了实现正确的关闭顺序，即日志（logging）要保持可用直到所有普通actor终止，即使日志本身也是用actor实现的。</p>
<ul>
<li>/: 根守护者</li>
</ul>
<p>根守护者所谓“顶级”actor的祖父，它监督所有在Actor路径的顶级作用域中定义的特殊actor，使用发现任何Exception就终止子actor的SupervisorStrategy.stoppingStrategy策略。</p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启过程中所发生事件的精确次序是：</p>
<ol>
<li>actor被挂起（意味着它不会处理正常消息直到被恢复），并递归挂起其所有子actor</li>
<li>调用旧实例的 preRestart hook (缺省实现是向所有子actor发送终止请求并调用 postStop)</li>
<li>等待所有子actor终止（使用context.stop()）直到 preRestart 最终结束；这里所有的actor操作都是非阻塞的，最后被杀掉的子actor的终止通知会影响下一步的执行</li>
<li>再次调用原来提供的工厂生成actor的新实例</li>
<li>调用新实例的postRestart方法（其默认实现是调用preStart方法）</li>
<li>对步骤3中没有被杀死的所有子actor发送重启请求；重启的actor会遵循相同的过程， 从步骤2开始</li>
<li>恢复这个actor</li>
</ol>
<h2 id="Actor引用-路径与地址"><a href="#Actor引用-路径与地址" class="headerlink" title="Actor引用, 路径与地址"></a>Actor引用, 路径与地址</h2><h3 id="什么是Actor引用？"><a href="#什么是Actor引用？" class="headerlink" title="什么是Actor引用？"></a>什么是Actor引用？</h3><p>Actor引用是 ActorRef 的子类，其最重要的目的是支持向它所代表的actor发送消息。每个actor通过self字段来访问自己的标准（本地）引用；在给其它actor发送的消息中也缺省包含这个引用。反过来，在消息处理过程中，actor可以通过sender()方法来访问到当前消息的发送者的引用。</p>
<h3 id="什么是Actor路径"><a href="#什么是Actor路径" class="headerlink" title="什么是Actor路径?"></a>什么是Actor路径?</h3><p>由于actor是以一种严格的树形结构样式来创建的，所以沿着子actor到父actor的监管链，一直到actor系统的根存在一条唯一的actor名字序列。这个序列可以被看做是文件系统中的文件路径，所以我们称之为“路径”。就像在一些真正的文件系统中一样，也存在所谓的“符号链接”，即一个actor也许能通过不同的路径被访问到，除了原始路径外，其它的路径都涉及到对actor实际监管祖先链的某部分路径进行转换的方法。</p>
<h3 id="如何获得Actor引用？"><a href="#如何获得Actor引用？" class="headerlink" title="如何获得Actor引用？"></a>如何获得Actor引用？</h3><p>actor引用的获取方法分为两类：通过创建actor，或者通过查找actor。后一种功能又分两种：通过具体的actor路径来创建actor引用，和查询actor逻辑树。</p>
<h4 id="创建Actor"><a href="#创建Actor" class="headerlink" title="创建Actor"></a>创建Actor</h4><p>一个actor系统通常是在根守护者上使用ActorSystem.actorOf创建actor来启动，然后在创建出的actor中使用ActorContext.actorOf来展开actor树。这些方法返回的是指向新创建的actor的引用。每个actor都拥有到它的父亲，它自己和它的子actor的引用（通过ActorContext访问）。这些引用可以与消息一起被发送给别的actor，以便接收方直接回复。</p>
<h4 id="通过具体的路径来查找actor"><a href="#通过具体的路径来查找actor" class="headerlink" title="通过具体的路径来查找actor"></a>通过具体的路径来查找actor</h4><p>另外，可以使用ActorSystem.actorSelection来查找actor引用。“选择”可在已有actor与被选择的actor进行通讯的时候用到，在投递每条消息的时候都会用到查找。</p>
<p>为了获得一个绑定到指定actor生命周期的ActorRef，你需要发送一个消息，如内置的Identify信息，向指定的actor，所获得的sender()即为所求。</p>
<p>val selection = context.actorSelection(“/user/serviceA”)<br>selection.tell(new Identify(identifyId), getSelf());</p>
<p>总结: actorOf vs. actorSelection vs. actorFor</p>
<p>Note</p>
<p>以上部分所描述的细节可以简要地总结和记忆成：</p>
<p>actorOf 永远都只会创建一个新的actor，这个新的actor是actorOf所调用上下文（可以是任意一个actor或actor系统本身）的直接子actor<br>actorSelection只会在消息送达后查找已经存在的actor集合，即不会创建actor，也不会在创建选择集合时验证actor是否存在。<br>actorFor（废弃，已经被actorSelection取代） 永远都只是查找到一个已存在的actor，不会创建新的actor。</p>
<h2 id="Actor路径的顶级作用域"><a href="#Actor路径的顶级作用域" class="headerlink" title="Actor路径的顶级作用域"></a>Actor路径的顶级作用域</h2><p>在路径树的根上是根监管者，所有其他actor都可以从通过它找到；它的名字是”/“。在第二个层次上是以下这些：</p>
<ul>
<li>“/user” 是所有由用户创建的顶级actor的监管者；用 ActorSystem.actorOf创建的actor在其下。</li>
<li>“/system” 是所有由系统创建的顶级actor的监管者，如日志监听器，或由配置指定在actor系统启动时自动部署的actor。</li>
<li>“/deadLetters” 是死信actor，所有发往已经终止或不存在的actor的消息会被重定向到这里（以尽最大努力为基础：即使在本地JVM，消息也可能丢失）</li>
<li>“/temp”是所有系统创建的短时actor的监管者，例如那些在ActorRef.ask的实现中用到的actor。</li>
<li>“/remote” 是一个人造虚拟路径，用来存放所有其监管者是远程actor引用的actor。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/Akka Actor的创建-引用-声明周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/Akka Actor的创建-引用-声明周期/" itemprop="url">Akka Actor的创建&引用&声明周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:09:54+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Actor的创建-amp-引用-amp-声明周期"><a href="#Actor的创建-amp-引用-amp-声明周期" class="headerlink" title="Actor的创建&amp;引用&amp;声明周期"></a>Actor的创建&amp;引用&amp;声明周期</h1><h2 id="1-创建actor"><a href="#1-创建actor" class="headerlink" title="1.创建actor"></a>1.创建actor</h2><ul>
<li>定义一个Actor类</li>
</ul>
<p>要定义自己的Actor类，需要继承Actor并实现receive方法。receive方法需要定义一系列case语句（类型为PartialFunction[Any, Unit]）来描述你的Actor能够处理哪些消息（使用标准的Scala模式匹配），以及消息如何被处理。<br>如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> =&gt; log.info(<span class="string">"received test"</span>)</span><br><span class="line">    <span class="keyword">case</span> _      =&gt; log.info(<span class="string">"received unknown message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Props</li>
</ul>
<p>Props是一个用来在创建actor时指定选项的配置类，可以把它看作是不可变的，因此在创建包含相关部署信息的actor时（例如使用哪一个调度器(dispatcher)，详见下文），是可以自由共享的。以下是如何创建Props实例的示例.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> props1 = <span class="type">Props</span>[<span class="type">MyActor</span>]</span><br><span class="line"><span class="keyword">val</span> props2 = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">ActorWithArgs</span>(<span class="string">"arg"</span>)) <span class="comment">// careful, see below</span></span><br><span class="line"><span class="keyword">val</span> props3 = <span class="type">Props</span>(classOf[<span class="type">ActorWithArgs</span>], <span class="string">"arg"</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>警告<br>在另一个actor中声明一个actor是非常危险的，会打破actor的封装。永远不要将一个actor的this引用传进Props！<br>推荐做法</p>
</blockquote>
<p>在每一个Actor的伴生对象中提供工厂方法是一个好主意，这有助于保持创建合适的Props，尽可能接近actor的定义。这也避免了使用Props.apply(…)方法将采用一个“按名”（by-name）参数的缺陷，因为伴生对象的给定代码块中将不会保留包含作用域的引用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DemoActor</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create Props for an actor of this type.</span></span><br><span class="line"><span class="comment">   * @param magciNumber The magic number to be passed to this actor’s constructor.</span></span><br><span class="line"><span class="comment">   * @return a Props for creating this actor, which can then be further configured</span></span><br><span class="line"><span class="comment">   *         (e.g. calling `.withDispatcher()` on it)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(magicNumber: <span class="type">Int</span>): <span class="type">Props</span> = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">DemoActor</span>(magicNumber))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActor</span>(<span class="params">magicNumber: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; sender() ! (x + magicNumber)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeOtherActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Props(new DemoActor(42)) would not be safe</span></span><br><span class="line">  context.actorOf(<span class="type">DemoActor</span>.props(<span class="number">42</span>), <span class="string">"demo"</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用Props创建Actor</li>
</ul>
<p>Actor可以通过将Props实例传入actorOf工厂方法来创建，ActorSystem和ActorContext中都有该方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorSystem is a heavy object: create only one per application</span></span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"mySystem"</span>)</span><br><span class="line"><span class="keyword">val</span> myActor = system.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>], <span class="string">"myactor2"</span>)</span><br><span class="line">使用<span class="type">ActorSystem</span>将创建顶级actor，由actor系统提供的守护actor监管；如果使用的是actor的上下文，则创建一个该actor的子actor。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> child = context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>], name = <span class="string">"myChild"</span>)</span><br><span class="line">  <span class="comment">// plus some behavior ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐创建一个树形结构，包含子actor、孙子等等，使之符合应用的逻辑错误处理结构</p>
<ul>
<li>依赖注入</li>
</ul>
<p>如果你的actor有带参数的构造函数，则这些参数也需要成为Props的一部分，如上文所述。但有些情况下必须使用工厂方法，例如，当实际构造函数的参数由依赖注入框架决定。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">IndirectActorProducer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependencyInjector</span>(<span class="params">applicationContext: <span class="type">AnyRef</span>, beanName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">IndirectActorProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actorClass</span> </span>= classOf[<span class="type">Actor</span>]</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">produce</span> </span>=</span><br><span class="line">    <span class="comment">// obtain fresh Actor instance from DI framework ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> actorRef = system.actorOf(</span><br><span class="line">  <span class="type">Props</span>(classOf[<span class="type">DependencyInjector</span>], applicationContext, <span class="string">"hello"</span>),</span><br><span class="line">  <span class="string">"helloBean"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="2-Actor-API"><a href="#2-Actor-API" class="headerlink" title="2.Actor API"></a>2.Actor API</h2><p>Actor trait只定义了一个抽象方法，就是上面提到的receive，用来实现actor的行为。</p>
<p><strong>如果当前actor的行为与收到的消息不匹配，则会调用 unhandled，其缺省实现是向actor系统的事件流中发布一条akka.actor.UnhandledMessage(message, sender, recipient)</strong>（将配置项akka.actor.debug.unhandled设置为on来将它们转换为实际的调试消息）。</p>
<p>另外，它还包括:</p>
<ul>
<li><strong>self引用代表本actor的ActorRef</strong></li>
<li><strong>sender引用代表最近收到消息的发送actor，通常用于下面将讲到的消息回应中</strong></li>
<li><strong>supervisorStrategy 用户可重写它来定义对子actor的监管策略</strong></li>
</ul>
<p>该策略通常在actor内声明，这样决定函数就可以访问actor的内部状态：因为失败通知作为消息发送给监管者，并像普通消息一样被处理（尽管不是正常行为），所有的值和actor变量都是可用的，以及sender引用 （报告失败的将是直接子actor；如果原始失败发生在遥远的后裔，它仍然是一次向上报告一层）。</p>
<ul>
<li>context暴露actor和当前消息的上下文信息，如：<ul>
<li>用于创建子actor的工厂方法（actorOf）</li>
<li>actor所属的系统</li>
<li>父监管者</li>
<li>所监管的子actor</li>
<li>生命周期监控</li>
<li>hotswap行为栈，见Become/Unbecome</li>
</ul>
</li>
</ul>
<h2 id="3-Actor生命周期"><a href="#3-Actor生命周期" class="headerlink" title="3.Actor生命周期"></a>3.Actor生命周期</h2><p><img src="http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/images/actor_lifecycle.png" alt="enter image description here"></p>
<p>actor系统中的路径代表一个”地方”，这里可能会被活着的actor占据。最初（除了系统初始化actor）路径都是空的。在调用actorOf()时它将为指定路径分配根据传入Props创建的一个actor化身。<strong>actor化身是由路径和一个UID标识的</strong>。重新启动只会替换有Props定义的Actor实例，但不会替换化身，因此UID保持不变。</p>
<p>当actor停止时，其化身的生命周期结束。在这一时间点上相关的生命周期事件被调用，监视该actor的actor都会获得终止通知。当化身停止后，路径可以重复使用，通过actorOf()创建一个actor。在这种情况下，除了UID不同外，新化身与老化身是相同的。</p>
<p><strong>ActorRef始终表示化身（路径和UID）而不只是一个给定的路径。因此如果actor停止，并且创建一个新的具有相同名称的actor，则指向老化身的ActorRef将不会指向新的化身。</strong></p>
<p>相对地，ActorSelection指向路径（或多个路径，如果使用了通配符），且完全不关注有没有化身占据它。因此ActorSelection 不能被监视。获取某路径下的当前化身ActorRef是可能的，只要向该ActorSelection发送Identify，如果收到ActorIdentity回应，则正确的引用就包含其中（详见通过Actor Selection确定Actor）。也可以使用ActorSelection的resolveOne方法，它会返回一个包含匹配ActorRef的Future。</p>
<ul>
<li>使用DeathWatch进行生命周期监控</li>
</ul>
<p>为了在其它actor终止时 (即永久停止，而不是临时的失败和重启)收到通知，actor可以将自己注册为其它<strong>actor在终止时所发布的Terminated消息</strong>的接收者（见停止 Actor）。这个服务是由actor系统的DeathWatch组件提供的。</p>
<p>注册一个监视器很简单：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Actor</span>, <span class="type">Props</span>, <span class="type">Terminated</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> child = context.actorOf(<span class="type">Props</span>.empty, <span class="string">"child"</span>)</span><br><span class="line">  context.watch(child) <span class="comment">// &lt;-- this is the only call needed for registration</span></span><br><span class="line">  <span class="keyword">var</span> lastSender = system.deadLetters</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"kill"</span> =&gt;</span><br><span class="line">      context.stop(child); lastSender = sender()</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`child`) =&gt; lastSender ! <span class="string">"finished"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要注意Terminated消息的产生与注册和终止行为所发生的顺序无关。特别地，即使在注册时，被观察的actor已经终止了，监视actor仍然会受到一个Terminated消息。</p>
<p>多次注册并不表示会有多个消息产生，也不保证有且只有一个这样的消息被接收到：如果被监控的actor已经生成了消息并且已经进入了队列，在这个消息被处理之前又发生了另一次注册，则会有第二个消息进入队列，因为对一个已经终止的actor的监控注册操作会立刻导致Terminated消息的产生。</p>
<p>可以使用context.unwatch(target)来停止对另一个actor生存状态的监控。即使Terminated已经加入邮箱，该操作仍有效；一旦调用unwatch，则被观察的actor的Terminated消息就都不会再被处理。</p>
<ul>
<li>启动Hook</li>
</ul>
<p>actor启动后，它的preStart方法会被立即执行。</p>
<p>override def preStart() {<br>  // registering with other actors<br>  someService ! Register(self)<br>}<br>在actor第一次创建时，将调用此方法。在重新启动期间，它被postRestart的默认实现调用，这意味着通过重写该方法，你可以选择是仅仅在初始化该actor时调用一次，还是为每次重新启动都调用。actor构造函数中的初始化代码将在每个actor实例创建的时候被调用，这也发生在每次重启时。</p>
<ul>
<li>重启Hook</li>
</ul>
<p>所有的actor都是被监管的，即与另一个使用某种失败处理策略的actor绑定在一起。如果在处理一个消息的时候抛出了异常，Actor将被重启（详见监管与监控）。这个重启过程包括上面提到的Hook：</p>
<p>要被重启的actor被通知是通过调用preRestart，包含着导致重启的异常以及触发异常的消息；如果重启并不是因为消息处理而发生的，则所携带的消息为None，例如，当一个监管者没有处理某个异常继而被其监管者重启时，或者因其兄弟节点的失败导致的重启。如果消息可用，则消息的发送者通常也可用（即通过调用sender）。</p>
<p>这个方法是用来完成清理、准备移交给新actor实例等操作的最佳位置。其缺省实现是终止所有子actor并调用postStop。</p>
<p>最初调用actorOf的工厂将被用来创建新的实例。<br>新的actor的postRestart方法被调用时，将携带着导致重启的异常信息。默认实现中，preStart被调用时，就像一个正常的启动一样。<br>actor的重启只会替换掉原来的actor对象；重启不影响邮箱的内容，所以对消息的处理将在postRestart hook返回后继续。触发异常的消息不会被重新接收。在actor重启过程中，所有发送到该actor的消息将象平常一样被放进邮箱队列中。</p>
<blockquote>
<p>警告<br>要知道失败通知与用户消息的相关顺序不是决定性的。尤其是，在失败以前收到的最后一条消息被处理之前，父节点可能已经重启其子节点了。详细信息请参见“讨论：消息顺序”。</p>
</blockquote>
<ul>
<li>终止 Hook</li>
</ul>
<p>一个Actor终止后，其postStop hook将被调用，它可以用来，例如取消该actor在其它服务中的注册。这个hook保证在该actor的消息队列被禁止后才运行，即之后发给该actor的消息将被重定向到ActorSystem的deadLetters中。</p>
<h2 id="3-通过Actor-Selection定位Actor"><a href="#3-通过Actor-Selection定位Actor" class="headerlink" title="3. 通过Actor Selection定位Actor"></a>3. 通过Actor Selection定位Actor</h2><p>如Actor引用, 路径与地址中所述，每个actor都拥有一个唯一的逻辑路径，此路径是由从actor系统的根开始的父子链构成；它还拥有一个物理路径，如果监管链包含有远程监管者，此路径可能会与逻辑路径不同。这些路径用来在系统中查找actor，例如，当收到一个远程消息时查找收件者，但是它们更直接的用处在于：actor可以通过指定绝对或相对路径（逻辑的或物理的）来查找其它的actor，并随结果获取一个ActorSelection：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will look up this absolute path</span></span><br><span class="line">context.actorSelection(<span class="string">"/user/serviceA/aggregator"</span>)</span><br><span class="line"><span class="comment">// will look up sibling beneath same supervisor</span></span><br><span class="line">context.actorSelection(<span class="string">"../joe"</span>)</span><br></pre></td></tr></table></figure></p>
<p>其中指定的路径被解析为一个java.net.URI，它以/分隔成路径段。如果路径以/开始，表示一个绝对路径，且从根监管者（”/user”的父亲）开始查找；否则是从当前actor开始。如果某一个路径段为..，会找到当前所遍历到的actor的上一级，否则则会向下一级寻找具有该名字的子actor。 必须注意的是actor路径中的..总是表示逻辑结构，即其监管者。</p>
<p><strong>一个actor selection的路径元素中可能包含通配符，从而允许向匹配模式的集合广播该条消息</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will look all children to serviceB with names starting with worker</span></span><br><span class="line">context.actorSelection(<span class="string">"/user/serviceB/worker*"</span>)</span><br><span class="line"><span class="comment">// will look up all siblings beneath same supervisor</span></span><br><span class="line">context.actorSelection(<span class="string">"../*"</span>)</span><br></pre></td></tr></table></figure></p>
<p>消息可以通过ActorSelection发送，并且在投递每条消息时 ActorSelection的路径都会被查找。如果selection不匹配任何actor，则消息将被丢弃。</p>
<p>要获得ActorSelection的ActorRef，你需要发送一条消息到selection，然后使用答复消息的sender()引用即可。有一个内置的Identify消息，所有actor会理解它并自动返回一个包含ActorRef的ActorIdentity消息。此消息被遍历到的actor特殊处理为，如果一个具体的名称查找失败（即一个不含通配符的路径没有对应的活动actor），则会生成一个否定结果。请注意这并不意味着应答消息有到达保证，它仍然是一个普通的消息。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Actor</span>, <span class="type">Props</span>, <span class="type">Identify</span>, <span class="type">ActorIdentity</span>, <span class="type">Terminated</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follower</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> identifyId = <span class="number">1</span></span><br><span class="line">  context.actorSelection(<span class="string">"/user/another"</span>) ! <span class="type">Identify</span>(identifyId)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`identifyId`, <span class="type">Some</span>(ref)) =&gt;</span><br><span class="line">      context.watch(ref)</span><br><span class="line">      context.become(active(ref))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`identifyId`, <span class="type">None</span>) =&gt; context.stop(self)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">active</span></span>(another: <span class="type">ActorRef</span>): <span class="type">Actor</span>.<span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`another`) =&gt; context.stop(self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你也可以通过ActorSelection的resolveOne方法获取ActorSelection的一个ActorRef。如果存在这样的actor，它将返回一个包含匹配的ActorRef的Future。如果没有这样的actor 存在或识别没有在指定的时间内完成，它将以失败告终——akka.actor.ActorNotFound。</p>
<p>如果开启了远程调用，则远程actor地址也可以被查找:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.actorSelection(<span class="string">"akka.tcp://app@otherhost:1234/user/serviceB"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4.发送消息"></a>4.发送消息</h3><p>向actor发送消息需使用下列方法之一。</p>
<ul>
<li>!意思是“fire-and-forget”，即异步发送一个消息并立即返回。也称为tell。</li>
<li>?异步发送一条消息并返回一个Future代表一个可能的回应。也称为ask。<br>对每一个消息发送者，分别有消息顺序保证。</li>
</ul>
<blockquote>
<p>注意<br>使用ask有一些性能内涵，因为需要跟踪超时，需要有桥梁将Promise转为ActorRef，并且需要在远程情况下可访问。所以为了性能应该总选择tell，除非只能选择ask。</p>
</blockquote>
<h4 id="Tell-Fire-forget"><a href="#Tell-Fire-forget" class="headerlink" title="Tell: Fire-forget"></a>Tell: Fire-forget</h4><p>这是发送消息的推荐方式。 不会阻塞地等待消息。它拥有最好的并发性和可扩展性。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actorRef ! message</span><br></pre></td></tr></table></figure></p>
<p>如果是在一个Actor中调用 ，那么发送方的actor引用会被隐式地作为消息的sender(): ActorRef成员一起发送。目的actor可以使用它来向源actor发送回应， 使用sender() ! replyMsg。</p>
<p>如果不是从Actor实例发送的，sender成员缺省为 deadLetters actor引用。</p>
<h4 id="Ask-Send-And-Receive-Future"><a href="#Ask-Send-And-Receive-Future" class="headerlink" title="Ask: Send-And-Receive-Future"></a>Ask: Send-And-Receive-Future</h4><p>ask模式既包含actor也包含future，所以它是一种使用模式，而不是ActorRef的方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.pattern.&#123; ask, pipe &#125;</span><br><span class="line"><span class="keyword">import</span> system.dispatcher <span class="comment">// The ExecutionContext that will be used</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>(<span class="params">x: <span class="type">Int</span>, s: <span class="type">String</span>, d: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Request</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">implicit</span> <span class="title">val</span> <span class="title">timeout</span> </span>= <span class="type">Timeout</span>(<span class="number">5</span> seconds) <span class="comment">// needed for `?` below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f: <span class="type">Future</span>[<span class="type">Result</span>] =</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    x &lt;- ask(actorA, <span class="type">Request</span>).mapTo[<span class="type">Int</span>] <span class="comment">// call pattern directly</span></span><br><span class="line">    s &lt;- (actorB ask <span class="type">Request</span>).mapTo[<span class="type">String</span>] <span class="comment">// call by implicit conversion</span></span><br><span class="line">    d &lt;- (actorC ? <span class="type">Request</span>).mapTo[<span class="type">Double</span>] <span class="comment">// call by symbolic name</span></span><br><span class="line">  &#125; <span class="keyword">yield</span> <span class="type">Result</span>(x, s, d)</span><br><span class="line"></span><br><span class="line">f pipeTo actorD <span class="comment">// .. or ..</span></span><br><span class="line">pipe(f) to actorD</span><br></pre></td></tr></table></figure></p>
<h3 id="5-接收消息"><a href="#5-接收消息" class="headerlink" title="5.接收消息"></a>5.接收消息</h3><p>Actor必须实现receive方法来接收消息：</p>
<p>protected def receive: PartialFunction[Any, Unit]<br>这个方法应返回一个PartialFunction，例如一个“match/case”子句，消息可以与其中的不同分支进行scala模式匹配。如下例:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> =&gt; log.info(<span class="string">"received test"</span>)</span><br><span class="line">    <span class="keyword">case</span> _      =&gt; log.info(<span class="string">"received unknown message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-终止Actor"><a href="#6-终止Actor" class="headerlink" title="6.终止Actor"></a>6.终止Actor</h3><p>通过调用ActorRefFactory（即ActorContext或ActorSystem）的stop方法来终止一个actor。通常context用来终止子actor，而 system用来终止顶级actor。实际的终止操作是异步执行的，即stop可能在actor被终止之前返回。</p>
<p>actor的终止分两步: 第一步actor将挂起对邮箱的处理，并向所有子actor发送终止命令，然后处理来自子actor的终止消息直到所有的子actor都完成终止，最后终止自己（调用postStop，清空邮箱，向DeathWatch发布Terminated，通知其监管者）。这个过程保证actor系统中的子树以一种有序的方式终止，将终止命令传播到叶子结点并收集它们回送的确认消息给被终止的监管者。如果其中某个actor没有响应（即由于处理消息用了太长时间以至于没有收到终止命令），整个过程将会被阻塞。</p>
<p>在ActorSystem.shutdown()被调用时，系统根监管actor会被终止，以上的过程将保证整个系统的正确终止。</p>
<p>postStop() hook 是在actor被完全终止以后调用的。这是为了清理资源:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>() &#123;</span><br><span class="line">  <span class="comment">// clean up some resources ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>由于actor的终止是异步的，你不能马上使用你刚刚终止的子actor的名字；这会导致InvalidActorNameException。你应该 监视watch()正在终止的actor，并在Terminated最终到达后作为回应创建它的替代者。</p>
</blockquote>
<p>优雅地终止</p>
<p>如果你需要等待终止过程的结束，或者组合若干actor的终止次序，可以使用gracefulStop：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.pattern.gracefulStop</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Await</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> stopped: <span class="type">Future</span>[<span class="type">Boolean</span>] = gracefulStop(actorRef, <span class="number">5</span> seconds, <span class="type">Manager</span>.<span class="type">Shutdown</span>)</span><br><span class="line">  <span class="type">Await</span>.result(stopped, <span class="number">6</span> seconds)</span><br><span class="line">  <span class="comment">// the actor has been stopped</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// the actor wasn't stopped within 5 seconds</span></span><br><span class="line">  <span class="keyword">case</span> e: akka.pattern.<span class="type">AskTimeoutException</span> =&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Shutdown</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Manager</span>._</span><br><span class="line">  <span class="keyword">val</span> worker = context.watch(context.actorOf(<span class="type">Props</span>[<span class="type">Cruncher</span>], <span class="string">"worker"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"job"</span> =&gt; worker ! <span class="string">"crunch"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shutdown</span> =&gt;</span><br><span class="line">      worker ! <span class="type">PoisonPill</span></span><br><span class="line">      context become shuttingDown</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shuttingDown</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"job"</span> =&gt; sender() ! <span class="string">"service unavailable, shutting down"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`worker`) =&gt;</span><br><span class="line">      context stop self</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当gracefulStop()成功返回时，actor的postStop() hook将会被执行：在postStop()结束和gracefulStop()返回之间存在happens-before边界。</p>
<p>在上面的示例中自定义的Manager.Shutdown消息是发送到目标actor来启动actor的终止过程。你可以使用PoisonPill，但之后在停止目标actor之前，你与其他actor的互动的机会有限。在postStop中，可以处理简单的清理任务。</p>
<blockquote>
<p>警告<br>请记住，actor停止和其名称被注销是彼此异步发生的独立事件。因此，在gracefulStop()返回后。你会发现其名称仍可能在使用中。为了保证正确注销，只在你控制的监管者内，并且只在响应Terminated消息时重用名称，即不是用于顶级actor。</p>
</blockquote>
<h3 id="7-Become-Unbecome"><a href="#7-Become-Unbecome" class="headerlink" title="7.Become/Unbecome"></a>7.Become/Unbecome</h3><p>升级</p>
<p>Akka支持在运行时对Actor消息循环（即其实现）进行实时替换：在actor中调用context.become方法。become要求一个PartialFunction[Any, Unit]参数作为新的消息处理实现。 被替换的代码被保存在一个栈中，可以被push和pop。</p>
<blockquote>
<p>警告<br>请注意actor被其监管者重启后将恢复其最初的行为。</p>
</blockquote>
<h3 id="8-使用PartialFunction链来扩展actor"><a href="#8-使用PartialFunction链来扩展actor" class="headerlink" title="8.使用PartialFunction链来扩展actor"></a>8.使用PartialFunction链来扩展actor</h3><p>有时在一些actor中分享共同的行为，或通过若干小的函数构成一个actor的行为是很有用的。这由于actor的receive方法返回一个Actor.Receive（PartialFunction[Any,Unit]的类型别名）而使之成为可能，多个偏函数可以使用PartialFunction#orElse链接在一起。你可以根据需要链接尽可能多的功能，但是你要牢记”第一个匹配”获胜——这在组合可以处理同一类型的消息的功能时会很重要。</p>
<p>例如，假设你有一组actor是生产者Producers或消费者Consumers，然而有时候需要actor分享这两种行为。这可以很容易实现而无需重复代码，通过提取行为的特质和并将actor的receive实现为这些偏函数的组合。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProducerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">Actor</span> =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> producerBehavior: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GiveMeThings</span> =&gt;</span><br><span class="line">      sender() ! <span class="type">Give</span>(<span class="string">"thing"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> consumerBehavior: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> ref: <span class="type">ActorRef</span> =&gt;</span><br><span class="line">      ref ! <span class="type">GiveMeThings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Give</span>(thing) =&gt;</span><br><span class="line">      log.info(<span class="string">"Got a thing! It's &#123;&#125;"</span>, thing)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ProducerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= producerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> <span class="keyword">with</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= consumerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">ProducerBehavior</span> <span class="keyword">with</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= producerBehavior orElse consumerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GiveMeThings</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Give</span>(<span class="params">thing: <span class="type">Any</span></span>)</span></span><br></pre></td></tr></table></figure></p>
<p>不同于继承，相同的模式可以通过组合实现——可以简单地通过委托的偏函数组合成receive方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/03/Hystrix学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/Hystrix学习笔记/" itemprop="url">Hystrix学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-03T17:34:18+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>学习资料：<a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></p>
<h2 id="What-Is-Hystrix-For"><a href="#What-Is-Hystrix-For" class="headerlink" title="What Is Hystrix For?"></a>What Is Hystrix For?</h2><p>Hystrix is designed to do the following:</p>
<ul>
<li>Give protection from and control over latency and failure from dependencies accessed (typically over the network) via third-party client libraries.   让程序具有处理调用外部服务失败的能力</li>
<li>Stop cascading failures in a complex distributed system.</li>
<li>Fail fast and rapidly recover.</li>
<li>Fallback and gracefully degrade when possible.</li>
<li>Enable near real-time monitoring, alerting, and operational control.<h2 id="Hystrix-works-by"><a href="#Hystrix-works-by" class="headerlink" title="Hystrix works by:"></a>Hystrix works by:</h2></li>
<li>Preventing any single dependency from using up all container (such as Tomcat) user threads.</li>
<li>Shedding load and failing fast instead of queueing.</li>
<li>Providing fallbacks wherever feasible to protect users from failure.</li>
<li>Using isolation techniques (such as bulkhead, swimlane, and circuit breaker patterns) to limit the impact of any one dependency.</li>
<li>Optimizing for time-to-discovery through near real-time metrics, monitoring, and alerting</li>
<li>Optimizing for time-to-recovery by means of low latency propagation of configuration changes and support for dynamic property changes in most aspects of Hystrix, which allows you to make real-time operational modifications with low latency feedback loops.</li>
<li>Protecting against failures in the entire dependency client execution, not just in the network traffic.</li>
</ul>
<p>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>下面是一个HystrixCommand的简单的“hello world”实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandHelloWorld</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a real example would do work like a network call here</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###同步执行<br>Hystrix commands能通过execute()方法调用被同步的执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).execute();</span><br></pre></td></tr></table></figure></p>
<p>###异步执行<br>异步执行通过调用queue()方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; fs = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).queue();</span><br></pre></td></tr></table></figure></p>
<p>###响应式执行<br>响应式执行（异步回调）通过使用observe() 执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; fs = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).observe();</span><br></pre></td></tr></table></figure></p>
<p>返回值可以通过订阅Observable获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// value emitted here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>优美的降级可以通过增加一个getFallback()实现来达到。该方法在各种类型的失败后执行。如： run（）方<br>法调用失败，超时，线程池，信号丢弃以及熔断器短路。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello Failure "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><p>从run（）方法中抛出的所以异常(除了HystrixBadRequestException)都被计为异常。将触发getFallback()<br>和熔断逻辑。在HystrixBadRequestException中抛出的例外，你可以根据你的喜好进行包装，然后通过<br>getCause()获取。<br>HystrixBadRequestException设计的使用场景为，报告不合法的参数或非系统性错误。这些都不能计入失<br>败次数的度量，也不应当触发回退逻辑</p>
<h2 id="Command-Name"><a href="#Command-Name" class="headerlink" title="Command Name"></a>Command Name</h2><h2 id="Command-Group"><a href="#Command-Group" class="headerlink" title="Command Group"></a>Command Group</h2><p>group进行统一管理<br>command组键名被用于将command分组，如报表，警告，面板或者组包的所以者。<br>默认情况下，它被用于command的线程池的命名，除非有单独的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Setter cachedSetter = </span><br><span class="line">        Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"HelloWorld"</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cachedSetter);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Command线程池"><a href="#Command线程池" class="headerlink" title="Command线程池"></a>Command线程池</h2><p>线程池的键被用于监控HystrixThreadPool时的呈现，度量的发布，缓存等其它应用。一个<br>HystrixCommand 是和一个单个的HystrixThreadPool相关联，通过注入它的HystrixThreadPoolKey可以取<br>得HystrixThreadPool 或者它默认情况下用HystrixCommandGroupKey创建一个。</p>
<h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><p>请求缓存通过实现<figure class="highlight plain"><figcaption><span>```或者```HystrixObservableCommand```中的``` getCacheKey() ```方法完成：依赖于request context 的某些东西，必须实例化HystrixRequestContext</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">``` java</span><br><span class="line">public class CommandUsingRequestCache extends HystrixCommand&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    protected CommandUsingRequestCache(int value) &#123;</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;));</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean run() &#123;</span><br><span class="line">        return value == 0 || value % 2 == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getCacheKey() &#123;</span><br><span class="line">        return String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>请求合并是一个特性，它能自动将一批请求合并到单一的HystrixCommand实例中执行。<br>可以设定批次的大小和时间作为促发器来执行一个批次<br>两种style的请求合并</p>
<ul>
<li>request-scoped </li>
<li>globally-scoped.<br>This is configured at collapser construction, and defaulted to request-scoped.<h2 id="Request-Context-Setup"><a href="#Request-Context-Setup" class="headerlink" title="Request Context Setup"></a>Request Context Setup</h2>为了能使用request的scoped特性（请求缓存，请求折叠，请求日记）HystrixRequestContext 的生命周期<br>必须被管理起来。（或者一个替代的HystrixConcurrencyStrategy 实现）<br>这就意味着下面代码必须在一个请求之前执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在请求的最后调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.shutdown();</span><br></pre></td></tr></table></figure></p>
<h1 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h1><h2 id="快速失败-Fail-Fast"><a href="#快速失败-Fail-Fast" class="headerlink" title="快速失败 Fail Fast"></a>快速失败 Fail Fast</h2><h2 id="无声失败-Fail-Silent"><a href="#无声失败-Fail-Silent" class="headerlink" title="无声失败 Fail Silent"></a>无声失败 Fail Silent</h2><p>无声的失败等同于返回一个空的响应或者删除功能,它通过返回null，空的map对象，空的list或者其他类似<br>的响应实现。 通常通过HystrixCommand实例中的getFallback() 方法实现</p>
<h2 id="回退：静态的-Fallback-Static"><a href="#回退：静态的-Fallback-Static" class="headerlink" title="回退：静态的 Fallback:Static"></a>回退：静态的 Fallback:Static</h2><p>一些回退能返回在代码中硬编码的值。它不能引起特性或将被移除服务（如同无声失败经常处理的方<br>法），但是执行默认的行为逻辑。</p>
<h2 id="Fallback-Stubbed"><a href="#Fallback-Stubbed" class="headerlink" title="Fallback: Stubbed"></a>Fallback: Stubbed</h2><p>一个存根回退典型的被用于包含多个字段的一个组合对象被返回时。它们其中的一部分能被其它请求状态<br>来决定。当其它字段被设置为默认值。</p>
<h2 id="Fallback-Cache-via-Network"><a href="#Fallback-Cache-via-Network" class="headerlink" title="Fallback: Cache via Network"></a>Fallback: Cache via Network</h2><p>由于回退如果重掉网络可能导致另外的失败，因此需要通过另外的HystrixCommand转换。<br>另外重要的是，回退command应当在独立的线程池中执行。如果两个command共享相同的线程池，会导<br>致主command将变的延迟并且占用整个的线程池，从而阻止回退。</p>
<h2 id="主从都失效"><a href="#主从都失效" class="headerlink" title="主从都失效"></a>主从都失效</h2><p><img src="https://github.com/Netflix/Hystrix/wiki/images/primary-secondary-example-640.png" alt="enter image description here"><br>通过两个Command进行隔离</p>
<p>##Client Doesn’t Perform Network Access</p>
<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p><img src="https://github.com/Netflix/Hystrix/wiki/images/library-migration-to-hystrix-without-640.png" alt="enter image description here"><br>to<br><img src="https://github.com/Netflix/Hystrix/wiki/images/library-migration-to-hystrix-with-640.png" alt="enter image description here"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2015/02/03/动态分区说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/03/动态分区说明/" itemprop="url">动态分区说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-03T17:32:12+08:00">
                2015-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hive/" itemprop="url" rel="index">
                    <span itemprop="name">Hive</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hive分区"><a href="#Hive分区" class="headerlink" title="Hive分区"></a>Hive分区</h1><p><a href="http://lxw1234.com/archives/2015/06/286.htm" target="_blank" rel="noopener">Hive的动态分区</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>hive中支持两种类型的分区：</p>
<ul>
<li>静态分区SP（static partition）</li>
<li>动态分区DP（dynamic partition）</li>
</ul>
<p>静态分区与动态分区的主要区别在于静态分区是手动指定，而动态分区是通过数据来进行判断。详细来说，静态分区的列实在编译时期，通过用户传递来决定的；动态分区只有在SQL执行时才能决定。</p>
<h2 id="动态分区说明"><a href="#动态分区说明" class="headerlink" title="动态分区说明"></a>动态分区说明</h2><p>关系型数据库（如Oracle）中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>按照常规的方法向分区表中插入数据，如果源数据量很大，那么针对一个分区就要写一个insert，非常麻烦，你必须先要知道源数据中都有什么样的数据才能创建分区。<br>例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert overwrite table partition_test partition(stat_date='20110728',province='henan') select member_id,name from partition_test_input where stat_date='20110728' and province='henan';</span><br></pre></td></tr></table></figure></p>
<p>使用动态分区可以很好的解决上述问题。动态分区可以根据查询得到的数据自动匹配到相应的分区中去。<br>使用动态分区要先设置hive.exec.dynamic.partition参数值为true，默认值为false，即不允许使用：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; set hive.exec.dynamic.partition;</span><br><span class="line">hive.exec.dynamic.partition=false</span><br><span class="line">hive&gt; set hive.exec.dynamic.partition=true;</span><br><span class="line">hive&gt; set hive.exec.dynamic.partition;</span><br><span class="line">hive.exec.dynamic.partition=true</span><br></pre></td></tr></table></figure></p>
<p>动态分区的使用方法很简单，假设我想向stat_date=’20110728’这个分区下面插入数据，至于province插入到哪个子分区下面让数据库自己来判断，那可以这样写：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert overwrite table partition_test partition(stat_date='20110728',province)</span><br><span class="line">&gt; select member_id,name,province from partition_test_input where stat_date='20110728';</span><br><span class="line">Total MapReduce jobs = 2</span><br><span class="line">...</span><br><span class="line">3 Rows loaded to partition_test</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>stat_date叫做<strong>静态分区列</strong>，province叫做<strong>动态分区列</strong>。select子句中需要把动态分区列按照分区的顺序写出来，静态分区列不用写出来。这样stat_date=’20110728’的所有数据，会根据province的不同分别插入到/user/hive/warehouse/partition_test/stat_date=20110728/下面的不同的子文件夹下，如果源数据对应的province子分区不存在，则会自动创建，非常方便，而且避免了人工控制插入数据与分区的映射关系存在的潜在风险。</p>
<ul>
<li>注意，动态分区不允许主分区采用动态列而副分区采用静态列，这样将导致所有的主分区都要创建副分区静态列所定义的分区</li>
<li>动态分区可以允许所有的分区列都是动态分区列，但是要首先设置一个参数hive.exec.dynamic.partition.mode ：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; set hive.exec.dynamic.partition.mode;</span><br><span class="line">hive.exec.dynamic.partition.mode=strict</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="动态分区demo"><a href="#动态分区demo" class="headerlink" title="动态分区demo"></a>动态分区demo</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.dynamic.partition=<span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">SET</span> hive.exec.dynamic.partition.mode=nonstrict; </span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions.pernode = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions=<span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> t_lxw1234_partitioned <span class="keyword">PARTITION</span> (<span class="keyword">month</span>,<span class="keyword">day</span>) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span>,<span class="keyword">substr</span>(<span class="keyword">day</span>,<span class="number">1</span>,<span class="number">7</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,<span class="keyword">day</span> </span><br><span class="line"><span class="keyword">FROM</span> t_lxw1234;</span><br></pre></td></tr></table></figure>
<h2 id="动态分区参数"><a href="#动态分区参数" class="headerlink" title="动态分区参数"></a>动态分区参数</h2><p>使用动态分区需要注意设定以下参数：</p>
<ul>
<li><p>hive.exec.dynamic.partition<br>默认值：false<br>是否开启动态分区功能，默认false关闭。<br>使用动态分区时候，该参数必须设置成true;</p>
</li>
<li><p>hive.exec.dynamic.partition.mode<br>默认值：strict<br>动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。<br>一般需要设置为nonstrict</p>
</li>
<li><p>hive.exec.max.dynamic.partitions.pernode<br>默认值：100<br>在每个执行MR的节点上，最大可以创建多少个动态分区。<br>该参数需要根据实际的数据来设定。<br>比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p>
</li>
<li><p>hive.exec.max.dynamic.partitions<br>默认值：1000<br>在所有执行MR的节点上，最大一共可以创建多少个动态分区。<br>同上参数解释。</p>
</li>
<li><p>hive.exec.max.created.files<br>默认值：100000<br>整个MR Job中，最大可以创建多少个HDFS文件。<br>一般默认值足够了，除非你的数据量非常大，需要创建的文件数大于100000，可根据实际情况加以调整。</p>
</li>
<li><p>hive.error.on.empty.partition<br>默认值：false<br>当有空分区生成时，是否抛出异常。<br>一般不需要设置。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Ke</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Ke</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
