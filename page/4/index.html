
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>雁渡寒潭 风吹疏竹</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Sun Ke">
    

    
    <meta name="description" content="人生不止眼前的苟且">
<meta property="og:type" content="website">
<meta property="og:title" content="雁渡寒潭 风吹疏竹">
<meta property="og:url" content="slamke.github.io/page/4/index.html">
<meta property="og:site_name" content="雁渡寒潭 风吹疏竹">
<meta property="og:description" content="人生不止眼前的苟且">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雁渡寒潭 风吹疏竹">
<meta name="twitter:description" content="人生不止眼前的苟且">

    
    <link rel="alternative" href="/atom.xml" title="雁渡寒潭 风吹疏竹" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="雁渡寒潭 风吹疏竹" title="雁渡寒潭 风吹疏竹"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="雁渡寒潭 风吹疏竹">雁渡寒潭 风吹疏竹</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:slamke.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/15/Scala隐式转换和隐式参数/" title="Scala隐式转换和隐式参数" itemprop="url">Scala隐式转换和隐式参数</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-05-15T03:27:59.000Z" itemprop="datePublished"> 發表於 2017-05-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Scala的implicit功能很强大，可以自动地给对象”添加一个属性”。 这里打上引号的原因是Scala内部进行编译的时候会自动加上隐式转换函数。</p>
<p>很多Scala开源框架内部都大量使用了implicit。因为implicit真的很强大，写得好的implicit可以让代码更优雅。但个人感觉implicit也有一些缺点，比如使用了implicit之后，看源码或者使用一些library的时候无法下手，因为你根本不知道作者哪里写了implicit。这个也会对初学者造成一些困扰。</p>
<p>比如Scala中Option就有一个implicit可以将Option转换成Iterable：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">11</span>, <span class="number">2</span> -&gt; <span class="number">22</span>, <span class="number">3</span> -&gt; <span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> newList = list.flatMap &#123;</span><br><span class="line">    num =&gt; map.get(num) <span class="comment">// map.get方法返回的是Option，可以被隐式转换成Iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是implicit的一个小例子。</p>
<p>比如以下一个例子，定义一个Int类型的变量num，但是赋值给了一个Double类型的数值。这时候就会编译错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> num: <span class="type">Int</span> = <span class="number">3.5</span> <span class="comment">// Compile Error</span></span><br></pre></td></tr></table></figure>
<p>但是我们加了一个隐式转换之后，就没问题了:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Int</span></span>(d: <span class="type">Double</span>) = d.toInt</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> num: <span class="type">Int</span> = <span class="number">3.5</span> <span class="comment">// 3， 这段代码会被编译成 val num: Int = double2Int(3.5)</span></span><br></pre></td></tr></table></figure>
<h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><h3 id="标记规则-Marking-Rule"><a href="#标记规则-Marking-Rule" class="headerlink" title="标记规则(Marking Rule)"></a>标记规则(Marking Rule)</h3><p>任何变量，函数或者对象都可以用implicit这个关键字进行标记，表示可以进行隐式转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToString</span></span>(x: <span class="type">Int</span>) = x.toString</span><br></pre></td></tr></table></figure>
<p>编译器可能会将x + y 转换成 convert(x) + y 如果convert被标记成implicit。<br>同样只有哪些使用 implicit 关键字的定义才是可以使用的隐式定义。<strong>关键字 implicit 用来标记一个隐式定义</strong>。编译器才可以选择它作为隐式变化的候选项。你可以使用 implicit 来标记任意变量，函数或是对象。</p>
<h3 id="作用域规则-Scope-Rule"><a href="#作用域规则-Scope-Rule" class="headerlink" title="作用域规则(Scope Rule)"></a>作用域规则(Scope Rule)</h3><p>在一个作用域内，一个隐式转换必须是一个唯一的标识。</p>
<p>比如说MyUtils这个object里有很多隐式转换。x + y 不会使用MyUtils里的隐式转换。 除非import进来。 import MyUtils._</p>
<p>Scala编译器还能在companion class中去找companion object中定义的隐式转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">getClub</span></span>(player: <span class="type">Player</span>): <span class="type">Club</span> = <span class="type">Club</span>(player.clubName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span>, val clubName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Player</span>(<span class="string">"costa"</span>, <span class="number">27</span>, <span class="string">"Chelsea"</span>)</span><br><span class="line"></span><br><span class="line">println(p.welcome) <span class="comment">// Chelsea welcome you here!</span></span><br><span class="line">println(p.playerNum) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<h3 id="一次编译只隐式转换一次-One-at-a-time-Rule"><a href="#一次编译只隐式转换一次-One-at-a-time-Rule" class="headerlink" title="一次编译只隐式转换一次(One-at-a-time Rule)"></a>一次编译只隐式转换一次(One-at-a-time Rule)</h3><p>Scala不会把 x + y 转换成 convert1(convert2(x)) + y</p>
<h2 id="隐式转换类型"><a href="#隐式转换类型" class="headerlink" title="隐式转换类型"></a>隐式转换类型</h2><h3 id="隐式转换成正确的类型"><a href="#隐式转换成正确的类型" class="headerlink" title="隐式转换成正确的类型"></a>隐式转换成正确的类型</h3><p>这种类型是Scala编译器对隐式转换的第一选择。 比如说编译器看到一个类型的X的数据，但是需要一个类型为Y的数据，那么就会去找把X类型转换成Y类型的隐式转换。</p>
<p>本文一开始的double2Int方法就是这种类型的隐式转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Int</span></span>(d: <span class="type">Double</span>) = d.toInt</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> num: <span class="type">Int</span> = <span class="number">3.5</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>当编译器发现变量num是个Int类型，并且用Double类型给它赋值的时候，会报错。 但是在报错之前，编译器会查找Double =&gt; Int的隐式转换。然后发现了double2Int这个隐式转换函数。于是就使用了隐式转换。</p>
<h3 id="方法调用的隐式转换"><a href="#方法调用的隐式转换" class="headerlink" title="方法调用的隐式转换"></a>方法调用的隐式转换</h3><p>比如这段代码 obj.doSomeThing。 比如obj对象没有doSomeThing这个方法，编译器会会去查找拥有doSomeThing方法的类型，并且看obj类型是否有隐式转换成有doSomeThing类型的函数。有的话就是将obj对象隐式转换成拥有doSomeThing方法的对象。</p>
<p>以下是一个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(num: <span class="type">Int</span>) = age + num</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(p: <span class="type">Person</span>) = age + p.age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = <span class="type">Person</span>(<span class="string">"format"</span>, <span class="number">99</span>)</span><br><span class="line">println(person + <span class="number">1</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="comment">//  println(1 + person)  报错，因为Int的+方法没有有Person参数的重载方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">personAddAge</span></span>(x: <span class="type">Int</span>) = <span class="type">Person</span>(<span class="string">"unknown"</span>, x)</span><br><span class="line"></span><br><span class="line">println(<span class="number">1</span> + person) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>**<br>有了隐式转换方法之后，编译器检查 1 + person 表达式，发现Int的+方法没有有Person参数的重载方法。在放弃之前查看是否有将Int类型的对象转换成以Person为参数的+方法的隐式转换函数，于是找到了，然后就进行了隐式转换。</p>
<p>Scala的Predef中也使用了方法调用的隐式转换。</p>
<p>Map(1 -&gt; 11, 2 -&gt; 22)<br>上面这段Map中的参数是个二元元组。 Int没有 -&gt; 方法。 但是在Predef中定义了：</p>
<p>implicit final class ArrowAssoc<a href="private val self: A">A</a> extends AnyVal {<br>    @inline def -&gt; <a href="y: B" target="_blank" rel="external">B</a>: Tuple2[A, B] = Tuple2(self, y)<br>    def →<a href="y: B" target="_blank" rel="external">B</a>: Tuple2[A, B] = -&gt;(y)<br>}</p>
<h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p><strong>隐式参数的意义是当方法需要多个参数的时候，可以定义一些隐式参数，这些隐式参数可以被自动加到方法填充的参数里，而不必手填充</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicitParamFunc</span></span>(name: <span class="type">String</span>)(<span class="keyword">implicit</span> tiger: <span class="type">Tiger</span>, lion: <span class="type">Lion</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(name + <span class="string">" have a tiget and a lion, their names are: "</span> + tiger.name + <span class="string">", "</span> + lion.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> tiger = <span class="type">Tiger</span>(<span class="string">"tiger1"</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> lion = <span class="type">Lion</span>(<span class="string">"lion1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Zoo</span>._</span><br><span class="line"></span><br><span class="line">implicitParamFunc(<span class="string">"format"</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个代码中implicitParamFunc中的第二个参数定义成了隐式参数。</p>
<p>然后在Zoo对象里定义了两个隐式变量，import进来之后，调用implicitParamFunc方法的时候这两个变量被自动填充到了参数里。</p>
<p>这里需要注意的是<strong>不仅仅方法中的参数需要被定义成隐式参数，对应的隐式参数的变量也需要被定义成隐式变量</strong>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对象中的隐式转换可以只import自己需要的。</p>
<p>object MyUtils {<br>    implicit def a …<br>    implicit def b …<br>}</p>
<p>import MyUtils.a<br>隐式转换修饰符implicit可以修饰class，method，变量，object。</p>
<p>修饰方法和变量的隐式转换本文已经介绍过，就不继续说了。</p>
<p>修饰class的隐式转换，它的作用跟修饰method的隐式转换类似：</p>
<p>implicit class RangeMarker(val start: Int) {<br>    def –&gt;(end: Int) = start to end<br>}</p>
<p>1 –&gt; 10 // Range(1, 10)<br>上段代码可以改造成使用Value Class完成类的隐式转换：</p>
<p>implicit class RangeMaker(start: Int) extends AnyVal {<br>    def –&gt;(end: Int) = start to end<br>}<br>修饰object的隐式转换：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Calculate</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">IntCal</span> <span class="keyword">extends</span> <span class="title">Calculate</span>[<span class="type">Int</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">ListCal</span> <span class="keyword">extends</span> <span class="title">Calculate</span>[<span class="type">List</span>[<span class="type">Int</span>]] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">List</span>[<span class="type">Int</span>], y: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = x ::: y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">implicitObjMethod</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>)(<span class="keyword">implicit</span> cal: <span class="type">Calculate</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(x + <span class="string">" + "</span> + y + <span class="string">" = "</span> + cal.add(x, y))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">implicitObjMethod(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1 + 2 = 3</span></span><br><span class="line">implicitObjMethod(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// List(1, 2) + List(3, 4) = List(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Scala/">Scala</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Scala/">Scala</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/12/Spark如何处理异常/" title="Spark如何处理异常" itemprop="url">Spark如何处理异常</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-05-12T09:07:52.000Z" itemprop="datePublished"> 發表於 2017-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="异步执行和异常处理"><a href="#异步执行和异常处理" class="headerlink" title="异步执行和异常处理"></a>异步执行和异常处理</h2><p>Spark使用RDD作为基本单元来构建基于大量数据的算法.</p>
<p>在RDD上你有两个操作:转换 transformation和行动 actions.转换操作会通过前一个RDD构建一个新的RDD.比如map和flatMap.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines:<span class="type">RDD</span>[<span class="type">String</span>]=sc.textFile(<span class="string">"large_file.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> tokens = lines.flatMap(_ split <span class="string">" "</span>)</span><br></pre></td></tr></table></figure></p>
<p>而行动操作则基于RDD计算结果出来.然后返回给驱动程序或者保存到外部的存储系统(HDFS,HBase)等<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokens.saveAsTextFile(<span class="string">"/some/uotput/file.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后,关于RDD, 你需要记住: <figure class="highlight plain"><figcaption><span>you can define new RDDs any time, Spark computes them only in a lazy fashion —that is, the first time they are used in an action. ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在RDD上处理转换操作的时候, 可能会出错和抛出异常.通常的处理方法就是把转换操作用try-catch包裹起来</span><br><span class="line">``` scala</span><br><span class="line">val lines: RDD[String] = sc.textFile(&quot;large_file.txt&quot;)</span><br><span class="line">try &#123;</span><br><span class="line">    val tokens = lines.flatMap(_ split &quot; &quot;)</span><br><span class="line">     // This transformation can throw an exception</span><br><span class="line">     .map(s =&gt; s(10))</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    case e : StringIndexOutOfBoundsException =&gt; </span><br><span class="line">    // Doing something in response of the exception</span><br><span class="line">&#125;</span><br><span class="line">tokens.saveAsTextFile(&quot;/some/output/file.txt&quot;)</span><br></pre></td></tr></table></figure></p>
<p>不幸的是, 转换里的代码直到第一次行动 执行时才会真的执行.也就是说上面的处理异常的代码是完全无用的.我们能做的也就只能时把行动 操作用try-catch包裹起来<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"large_file.txt"</span>)</span><br><span class="line"><span class="keyword">val</span> tokens = </span><br><span class="line">    lines.flatMap(_ split <span class="string">" "</span>)</span><br><span class="line">    .map(s =&gt; s(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This try-catch block catch all the exceptions thrown by the </span></span><br><span class="line">    <span class="comment">// preceding transformations. </span></span><br><span class="line">    tokens.saveAsTextFile(<span class="string">"/some/output/file.txt"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e : <span class="type">StringIndexOutOfBoundsException</span> =&gt; </span><br><span class="line">    <span class="comment">// Doing something in response of the exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以看到,我们丢失了异常处理的位置</p>
<p>使用这种方法,我们会丢失抛出异常的元素.此外,Spark是用来处理大量数据的:我们能确定我们的目的就是仅仅因为一个RDD里一个元素的错误就要阻塞整个执行过程吗?</p>
<h2 id="函数式编程和异常处理"><a href="#函数式编程和异常处理" class="headerlink" title="函数式编程和异常处理"></a>函数式编程和异常处理</h2><p>第二种处理方法则是将try-catch移动到转换 操作中. 以上代码变为:</p>
<p>val tokens =<br>    lines.flatMap(_ split “ “)<br>       .map {<br>         s =&gt; try {<br>             s(10)<br>           } catch {<br>              case e : StringIndexOutOfBoundsException =&gt;<br>                // What the hell can we return in this case?<br>           }<br>       }   // end of map<br>通过这么做,我们重新获得了位置 特征! 但是,通过这种方法,我们又引入了另一个问题.先前说过: 一个转换操作从旧的RDD里构建了一个新的RDD.转换操作map的偏函数输入的原始类型是String=&gt;Char</p>
<p>为了保留这个特征,我们不得不在case语句中返回一个Char或他的子类型.我们该怎么选择?空的字符?一个特殊的字符? 这些选择显然迟早会造成其他的问题.<br>对于Spark Transformation算子中的异常处理，直接写try catch会导致需要添加很多额外的代码。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data = <span class="type">Seq</span>(<span class="string">"123"</span>, <span class="string">"12aa"</span>)</span><br><span class="line">  <span class="keyword">val</span> dataRDD = sc.parallelize(data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> intRDD = dataRDD.map &#123;</span><br><span class="line">    item =&gt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        item.toInt</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">NumberFormatException</span> =&gt;</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;.collect()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> anotherRDD = dataRDD.map &#123;</span><br><span class="line">  item =&gt;</span><br><span class="line">    <span class="type">Try</span>(item.toInt)</span><br><span class="line">&#125;.filter(_.isSuccess).collect()</span><br><span class="line">anotherRDD.foreach(println)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/04/谈谈Spark的计算本地性/" title="谈谈Spark的计算本地性" itemprop="url">谈谈Spark的计算本地性</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-05-04T02:51:46.000Z" itemprop="datePublished"> 發表於 2017-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>转载：<a href="http://coolplayer.net/2017/05/02/%E8%B0%88%E8%B0%88spark-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%AC%E5%9C%B0%E6%80%A7" target="_blank" rel="external">http://coolplayer.net/2017/05/02/%E8%B0%88%E8%B0%88spark-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%AC%E5%9C%B0%E6%80%A7</a></p>
<p>Spark 是计算追着数据走， Storm 是数据追着计算走， 所以如果数据量比较小，要求延迟比较小， 就适合storm， 但是如果数据量比较大， 这个时候如果传输数据， 就会碰到很大的带宽占用和性能下降， 这个时候就比较适合让计算去找数据.</p>
<p>但是在计算找数据的过程中， 是怎么让计算找到数据呢， 这个就是这篇文章谈的， spark 的计算本地性</p>
<p><img src="http://7xim8y.com1.z0.glb.clouddn.com/local1.jpg" alt=""></p>
<h2 id="不同的-Locality-Level"><a href="#不同的-Locality-Level" class="headerlink" title="不同的 Locality Level"></a>不同的 Locality Level</h2><ul>
<li>PROCESS_LOCAL: 数据和 task 在同一个executor jvm 中，最好的就是这种 locality。</li>
<li>NODE_LOCAL: 数据在同一个节点上。比如数据在同一个节点的另一个 executor上；或在 HDFS 上，恰好有 block 在同一个节点上。速度比 PROCESS_LOCAL 稍慢，因为数据需要在不同进程之间传递或从文件中读取</li>
<li>NO_PREF: 数据从哪里访问都一样快，不需要位置优先</li>
<li>RACK_LOCAL: 数据在同一机架的不同节点上。需要通过网络传输数据及文件 IO，比 NODE_LOCAL 慢</li>
<li>ANY: 数据在非同一机架的网络上，速度最慢</li>
</ul>
<p><img src="http://7xim8y.com1.z0.glb.clouddn.com/local2.jpg" alt=""></p>
<h2 id="Task-自己想在哪里执行"><a href="#Task-自己想在哪里执行" class="headerlink" title="Task 自己想在哪里执行"></a>Task 自己想在哪里执行</h2><p>我们来看下 task 自己想在哪里执行， 这要根据 task 处理的数据是否缓存， task 的数据所在的 host 和 rack来判断， 在 DAGScheduler 中， 每个分区每个 stage 会成为一个task， 每个 task 会根据自己分区的数据的情况，进行判断自己的 本地性Level，</p>
<p>getPreferredLocs -&gt; getPreferredLocsInternal</p>
<p>函数中， 会先判断是否rdd 本分区的数据是否已经缓存在 blockManager， 如果已经缓存， 获取到数据所在的 host 和 executorId， 然后设置本 task 的数据本地性 Level 为 PROCESS_LOCAL， 偏好某个 host 上的某个 executor 去执行，</p>
<p>如果没有缓存， 那么就不能是PROCESS_LOCAL ， 最多也就是个 NODE_LOCAL，会根据不同的RDD类型，来调用具体的 getPreferredLocations 来判断数据本地性 Level， 和数据本地性偏好</p>
<p>假如这里是HadoopRDD， 那么每个 task 处理的数据就是一个 HadoopPartition， 其实代表 hdfs 中的一份数据 InputSplit， 它定义了分割的长度及位置。分割长度 是指分割数据的大小（以字节为单位），而分割位置 是分割所在的机器结点名称组成的列表， 分割位置中就能获取到 数据所在的 host 和 rack，</p>
<p>如果数据源头是 kafka， 那么每个 task 处理的数据就是 KafkaRDDPartition， 其实对应每一个topic的每一个partition， preferredHosts 中记录着每个 topic 中每个 partition 所在的 host， 就直接可以当做 偏好的 host， 如果kafka中broker和Spark在同一个集群中，此时getPreferredLocations获取本地性就可以极大提高效率，因为没有了数据网络传输的成本。</p>
<p>以上两种都偏好某个 host 去执行</p>
<p>这里需要注意的是，这里找的数据源头是 rdd的顺着窄依赖， 往上找父依赖， 直到找到第一个窄依赖， 也就找到了数据读取源头， 来决定数据本地性</p>
<p>如果读取的是 shuffle 的数据， 就不用考虑那么多了， 因为shuffle中的read task 是需要去所有的write task的disk上拉取数据的。</p>
<h2 id="怎么能最大程度的满足-task-的本地性"><a href="#怎么能最大程度的满足-task-的本地性" class="headerlink" title="怎么能最大程度的满足 task 的本地性"></a>怎么能最大程度的满足 task 的本地性</h2><p>我们都知道， 数据传输对内网带宽和性能有极大的损耗，所以要千方百计的最大程度的满足 更高级别的本地性，从优到差排， PROCESS_LOCAL &gt; NODE_LOCAL &gt; NO_PREF &gt; RACK_LOCAL</p>
<p>所以spark 调度的总体原则就是总是尝试以最高的 locality level 去启动task， 如果对应需要是用到的 executor 正在使用中（跑别的task），满足不了， 就等一会（等待时间是有spark.locality.wait.process或spark.locality.wait.node或spark.locality.wait.rack来控制的）， 看看过一会这个忙线的host 或者 executor是不是解脱了， 如果已经空闲了，我就可以把 task 放在它最期望的 host 或者 executor 上去运行了， 这里赌的就是一般来说，task 执行耗时相对于网络传输/文件IO 要小得多，调度器多等待1 2秒可能就可以以更好的本地性执行 task，避免了更耗时的网络传输或文件IO， 也是极棒的。</p>
<h2 id="Spark的延迟调度"><a href="#Spark的延迟调度" class="headerlink" title="Spark的延迟调度"></a>Spark的延迟调度</h2><p>我们来看下 spark 的延迟调度的策略，</p>
<p>有时候 task 自己偏好某个 executor 中，</p>
<p>可以看下面的图直观理解一下</p>
<p><img src="http://7xim8y.com1.z0.glb.clouddn.com/local3.jpg" alt=""></p>
<p>所以spark 调度的总体原则就是总是尝试以最高的 locality level 去启动task，<br>我举个例子， 假如 一个 task 要处理的数据，在上一个 stage 中缓存下来了， 这个 task 期望的 就是以 PROCESS_LOCAL 来运行， 这个时候缓存数据的executor 不巧正在执行 其他的task， 那么我就等一会， 等多长时间呢， spark.locality.wait.process这么长时间， 如果时间超了， executor 还是没有空闲下来， 那么我没有办法， 我就以NODE_LOCAL 来运行 task， 这个时候我想到 同一台机器上其他 executor 上跨jvm 去拉取数据， 如果同一台机器上有其他空闲的 executor 可以满足， 就这么干， 如果没有， 等待 spark.locality.wait.node 时间， 还没有就以更低的 Locality Level 去执行这个 task。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/13/如何重构箭头型代码/" title="如何重构箭头型代码" itemprop="url">如何重构箭头型代码</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-04-13T02:37:03.000Z" itemprop="datePublished"> 發表於 2017-04-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>转载自： <a href="http://coolshell.cn/articles/17757.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">http://coolshell.cn/articles/17757.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
<p>本文主要起因是，一次在微博上和朋友关于嵌套好几层的if-else语句的代码重构的讨论，在微博上大家有各式各样的问题和想法。按道理来说这些都是编程的基本功，似乎不太值得写一篇文章，不过我觉得很多东西可以从一个简单的东西出发，到达本质，所以，我觉得有必要在这里写一篇的文章。不一定全对，只希望得到更多的讨论，因为有了更深入的讨论才能进步。</p>
<p>文章有点长，我在文章最后会给出相关的思考和总结陈词，你可以跳到结尾。</p>
<p>所谓箭头型代码，基本上来说就是下面这个图片所示的情况。</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2017/04/IMG_7411.jpg" alt=""></p>
<p>那么，这样“箭头型”的代码有什么问题呢？看上去也挺好看的，有对称美。但是……</p>
<p>关于箭头型代码的问题有如下几个：</p>
<p>1）我的显示器不够宽，箭头型代码缩进太狠了，需要我来回拉水平滚动条，这让我在读代码的时候，相当的不舒服。</p>
<p>2）除了宽度外还有长度，有的代码的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">总而言之，**“箭头型代码”如果嵌套太多，代码太长的话，会相当容易让维护代码的人（包括自己）迷失在代码中，因为看到最内层的代码时，你已经不知道前面的那一层一层的条件判断是什么样的，代码是怎么运行到这里的，所以，箭头型代码是非常难以维护和Debug的**。</span><br><span class="line"></span><br><span class="line">## 微博上的案例 与 Guard Clauses</span><br><span class="line">OK，我们先来看一下微博上的那个示例，代码量如果再大一点，嵌套再多一点，你很容易会在条件中迷失掉（下面这个示例只是那个“大箭头”下的一个小箭头）</span><br><span class="line">``` java</span><br><span class="line">FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) &#123;</span><br><span class="line">    int index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());</span><br><span class="line">    if (index != -1) &#123;</span><br><span class="line">        auto type = manager-&gt;expressionResolvings.Values()[index].type;</span><br><span class="line">        if (! types.Contains(type.Obj())) &#123;</span><br><span class="line">            types.Add(type.Obj());</span><br><span class="line">            if (auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L&quot;CastResult&quot;, true)) &#123;</span><br><span class="line">                int count = group-&gt;GetMethodCount();</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123; auto method = group-&gt;GetMethod(i);</span><br><span class="line">                    if (method-&gt;IsStatic()) &#123;</span><br><span class="line">                        if (method-&gt;GetParameterCount() == 1 &amp;&amp;</span><br><span class="line">                            method-&gt;GetParameter(0)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;</span><br><span class="line">                            method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;void&gt;() ) &#123;</span><br><span class="line">                            symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，可以把条件反过来写，然后就可以把箭头型的代码解掉了，重构的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">    auto type = manager-&gt;expressionResolvings.Values()[index].type;</span><br><span class="line">    <span class="keyword">if</span> ( types.Contains(type.Obj()))  <span class="keyword">continue</span>;</span><br><span class="line">     </span><br><span class="line">    types.Add(type.Obj());</span><br><span class="line"> </span><br><span class="line">    auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L<span class="string">"CastResult"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>  ( ! group ) <span class="keyword">continue</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> count = group-&gt;GetMethodCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; auto method = group-&gt;GetMethod(i);</span><br><span class="line">        <span class="keyword">if</span> (! method-&gt;IsStatic()) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( method-&gt;GetParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">               method-&gt;GetParameter(<span class="number">0</span>)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;</span><br><span class="line">               method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;<span class="keyword">void</span>&gt;() ) &#123;</span><br><span class="line">            symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种代码的重构方式叫 Guard Clauses</p>
<p>Martin Fowler 的 Refactoring 的网站上有相应的说明《Replace Nested Conditional with Guard Clauses》。<br>Coding Horror 上也有一篇文章讲了这种重构的方式 —— 《Flattening Arrow Code》<br>StackOverflow 上也有相关的问题说了这种方式 —— 《Refactor nested IF statement for clarity》<br>这里的思路其实就是，<strong>让出错的代码先返回，前面把所有的错误判断全判断掉，然后就剩下的就是正常的代码了</strong>。</p>
<h2 id="抽取成函数"><a href="#抽取成函数" class="headerlink" title="抽取成函数"></a>抽取成函数</h2><p>微博上有些人说，continue 语句破坏了阅读代码的通畅，我觉得他们一定没有好好读这里面的代码，其实，我们可以看到，所有的 if 语句都是在判断是否出错的情况，所以，在维护代码的时候，你可以完全不理会这些 if 语句，因为都是出错处理的，而剩下的代码都是正常的功能代码，反而更容易阅读了。当然，一定有不是上面代码里的这种情况，那么，不用continue ，我们还能不能重构呢？</p>
<p>当然可以，抽成函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">CopyMethodTypeInfo</span><span class="params">(auto &amp;method, auto &amp;group, auto &amp;symbol)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! method-&gt;IsStatic()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( method-&gt;GetParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">           method-&gt;GetParameter(<span class="number">0</span>)-&gt;GetType()-&gt;GetTypeDescriptor() == description::GetTypeDescriptor&lt;DescriptableObject&gt;() &amp;&amp;</span><br><span class="line">           method-&gt;GetReturn()-&gt;GetTypeDescriptor() != description::GetTypeDescriptor&lt;<span class="keyword">void</span>&gt;() ) &#123;</span><br><span class="line">        symbol-&gt;typeInfo = CopyTypeInfo(method-&gt;GetReturn());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpressionResolvings</span><span class="params">(auto &amp;manager, auto &amp;argument, auto &amp;symbol)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = manager-&gt;expressionResolvings.Keys().IndexOf(argument.Obj());</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    auto type = manager-&gt;expressionResolvings.Values()[index].type;</span><br><span class="line">    <span class="keyword">if</span> ( types.Contains(type.Obj())) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    types.Add(type.Obj());</span><br><span class="line">    auto group = type-&gt;GetTypeDescriptor()-&gt;GetMethodGroupByName(L<span class="string">"CastResult"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>  ( ! group ) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> count = group-&gt;GetMethodCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; auto method = group-&gt;GetMethod(i);</span><br><span class="line">        <span class="keyword">if</span> ( ! CopyMethodTypeInfo(method, group, symbol) ) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">FOREACH(Ptr&lt;WfExpression&gt;, argument, node-&gt;arguments) &#123;</span><br><span class="line">    ExpressionResolvings(manager, arguments, symbol)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>你发出现，抽成函数后，代码比之前变得更容易读和更容易维护了。不是吗？</p>
<p>有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护。这才是函数的作用。</p>
<h2 id="嵌套的-if-外的代码"><a href="#嵌套的-if-外的代码" class="headerlink" title="嵌套的 if 外的代码"></a>嵌套的 if 外的代码</h2><p>微博上还有人问，原来的代码如果在各个 if 语句后还有要执行的代码，那么应该如何重构。比如下面这样的代码。</p>
<p>原版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(....) &#123;</span><br><span class="line">    do_before_cond1()</span><br><span class="line">    <span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">        do_before_cond2();</span><br><span class="line">        <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">            do_before_cond3();</span><br><span class="line">            <span class="keyword">if</span> (cond3) &#123;</span><br><span class="line">                do_something();</span><br><span class="line">            &#125;</span><br><span class="line">            do_after_cond3();</span><br><span class="line">        &#125;</span><br><span class="line">        do_after_cond2();</span><br><span class="line">    &#125;</span><br><span class="line">    do_after_cond1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码中的那些 <strong>do_after_condX()</strong> 是无论条件成功与否都要执行的。所以，我们拉平后的代码如下所示：</p>
<p>重构第一版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(....) &#123;</span><br><span class="line">    do_before_cond1();</span><br><span class="line">    <span class="keyword">if</span> ( !cond1 ) &#123;</span><br><span class="line">        do_after_cond1();</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125; </span><br><span class="line">    do_after_cond1();</span><br><span class="line"> </span><br><span class="line">    do_before_cond2();</span><br><span class="line">    <span class="keyword">if</span> ( !cond2 ) &#123; </span><br><span class="line">        do_after_cond2();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_after_cond2();</span><br><span class="line"> </span><br><span class="line">    do_before_cond3();</span><br><span class="line">    <span class="keyword">if</span> ( !cond3 ) &#123;</span><br><span class="line">        do_after_cond3();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_after_cond3();</span><br><span class="line"> </span><br><span class="line">    do_something();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现，上面的 do_after_condX 出现了两份。<strong>如果 if 语句块中的代码改变了某些do_after_condX依赖的状态，那么这是最终版本</strong>。</p>
<p>但是，如果它们之前没有依赖关系的话，根据 DRY 原则，我们就可以只保留一份，那么直接掉到 if 条件前就好了，如下所示：</p>
<p>重构第二版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(....) &#123;</span><br><span class="line">    do_before_cond1();</span><br><span class="line">    do_after_cond1();</span><br><span class="line">    <span class="keyword">if</span> ( !cond1 ) <span class="keyword">continue</span>;</span><br><span class="line">  </span><br><span class="line">    do_before_cond2();</span><br><span class="line">    do_after_cond2();</span><br><span class="line">    <span class="keyword">if</span> ( !cond2 ) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">    do_before_cond3();</span><br><span class="line">    do_after_cond3();</span><br><span class="line">    <span class="keyword">if</span> ( !cond3 ) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">    do_something();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，你会说，我靠，居然，改变了执行的顺序，把条件放到 do_after_condX() 后面去了。这会不会有问题啊？</p>
<p>其实，你再分析一下之前的代码，你会发现，本来，cond1 是判断 do_before_cond1() 是否出错的，如果有成功了，才会往下执行。而 do_after_cond1() 是无论如何都要执行的。从逻辑上来说，do_after_cond1()其实和do_before_cond1()的执行结果无关，而 cond1 却和是否去执行 do_before_cond2() 相关了。如果我把断行变成下面这样，反而代码逻辑更清楚了。</p>
<p>重构第三版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(....) &#123;</span><br><span class="line"> </span><br><span class="line">    do_before_cond1();</span><br><span class="line">    do_after_cond1();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !cond1 ) <span class="keyword">continue</span>;  <span class="comment">// &lt;-- cond1 成了是否做第二个语句块的条件</span></span><br><span class="line">    do_before_cond2();</span><br><span class="line">    do_after_cond2();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !cond2 ) <span class="keyword">continue</span>; <span class="comment">// &lt;-- cond2 成了是否做第三个语句块的条件</span></span><br><span class="line">    do_before_cond3();</span><br><span class="line">    do_after_cond3();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !cond3 ) <span class="keyword">continue</span>; <span class="comment">//&lt;-- cond3 成了是否做第四个语句块的条件</span></span><br><span class="line">    do_something(); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是乎，在未来维护代码的时候，维护人一眼看上去就明白，代码在什么时候会执行到哪里。 这个时候，你会发现，把这些语句块抽成函数，代码会干净的更多，再重构一版：</p>
<p>重构第四版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">do_func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   do_before_cond2();</span><br><span class="line">   do_after_cond2();</span><br><span class="line">   <span class="keyword">return</span> cond3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">bool <span class="title">do_func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   do_before_cond2();</span><br><span class="line">   do_after_cond2();</span><br><span class="line">   <span class="keyword">return</span> cond2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">bool <span class="title">do_func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   do_before_cond1();</span><br><span class="line">   do_after_cond1();</span><br><span class="line">   <span class="keyword">return</span> cond1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for-loop 你可以重构成这样</span></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    bool cond = do_func1();</span><br><span class="line">    <span class="keyword">if</span> (cond) cond = do_func2();</span><br><span class="line">    <span class="keyword">if</span> (cond) cond = do_func3();</span><br><span class="line">    <span class="keyword">if</span> (cond) do_something();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for-loop 也可以重构成这样</span></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! do_func1() ) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ! do_func2() ) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ! do_func3() ) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">   do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面，我给出了两个版本的for-loop，你喜欢哪个？我喜欢第二个。这个时候，因为for-loop里的代码非常简单，就算你不喜欢 continue ，这样的代码阅读成本已经很低了。</p>
<h2 id="状态检查嵌套"><a href="#状态检查嵌套" class="headerlink" title="状态检查嵌套"></a>状态检查嵌套</h2><p>接下来，我们再来看另一个示例。下面的代码的伪造了一个场景——把两个人拉到一个一对一的聊天室中，因为要检查双方的状态，所以，代码可能会写成了“箭头型”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConnectPeer2Peer</span><span class="params">(Conn *pA, Conn* pB, Manager *manager)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( pA-&gt;isConnected() ) &#123;</span><br><span class="line">        manager-&gt;Prepare(pA);</span><br><span class="line">        <span class="keyword">if</span> ( pB-&gt;isConnected() ) &#123;</span><br><span class="line">            manager-&gt;Prepare(pB);</span><br><span class="line">            <span class="keyword">if</span> ( manager-&gt;ConnectTogther(pA, pB) ) &#123;</span><br><span class="line">                pA-&gt;Write(<span class="string">"connected"</span>);</span><br><span class="line">                pB-&gt;Write(<span class="string">"connected"</span>);</span><br><span class="line">                <span class="keyword">return</span> S_OK;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> S_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pA-&gt;Write(<span class="string">"Peer is not Ready, waiting..."</span>);</span><br><span class="line">            <span class="keyword">return</span> S_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( pB-&gt;isConnected() ) &#123;</span><br><span class="line">            manager-&gt;Prepare();</span><br><span class="line">            pB-&gt;Write(<span class="string">"Peer is not Ready, waiting..."</span>);</span><br><span class="line">            <span class="keyword">return</span> S_RETRY;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pA-&gt;Close();</span><br><span class="line">            pB-&gt;Close();</span><br><span class="line">            <span class="keyword">return</span> S_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Shouldn't be here!</span></span><br><span class="line">    <span class="keyword">return</span> S_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构上面的代码，我们可以先分析一下上面的代码，说明了，上面的代码就是对 PeerA 和 PeerB 的两个状态 “连上”， “未连上” 做组合 “状态” （注：实际中的状态应该比这个还要复杂，可能还会有“断开”、“错误”……等等状态）， 于是，我们可以把代码写成下面这样，合并上面的嵌套条件，对于每一种组合都做出判断。这样一来，逻辑就会非常的干净和清楚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConnectPeer2Peer</span><span class="params">(Conn *pA, Conn* pB, Manager *manager)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( pA-&gt;isConnected() ) &#123;</span><br><span class="line">        manager-&gt;Prepare(pA);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( pB-&gt;isConnected() ) &#123;</span><br><span class="line">        manager-&gt;Prepare(pB);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// pA = YES &amp;&amp; pB = NO</span></span><br><span class="line">    <span class="keyword">if</span> (pA-&gt;isConnected() &amp;&amp; ! pB-&gt;isConnected()  ) &#123;</span><br><span class="line">        pA-&gt;Write(<span class="string">"Peer is not Ready, waiting"</span>);</span><br><span class="line">        <span class="keyword">return</span> S_RETRY;</span><br><span class="line">    <span class="comment">// pA = NO &amp;&amp; pB = YES</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( !pA-&gt;isConnected() &amp;&amp; pB-&gt;isConnected() ) &#123;</span><br><span class="line">        pB-&gt;Write(<span class="string">"Peer is not Ready, waiting"</span>);</span><br><span class="line">        <span class="keyword">return</span> S_RETRY;</span><br><span class="line">    <span class="comment">// pA = YES &amp;&amp; pB = YES</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pA-&gt;isConnected() &amp;&amp; pB-&gt;isConnected()  ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ! manager-&gt;ConnectTogther(pA, pB) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> S_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        pA-&gt;Write(<span class="string">"connected"</span>);</span><br><span class="line">        pB-&gt;Write(<span class="string">"connected"</span>);</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// pA = NO, pB = NO</span></span><br><span class="line">    pA-&gt;Close();</span><br><span class="line">    pB-&gt;Close();</span><br><span class="line">    <span class="keyword">return</span> S_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>对于<strong> if-else</strong> 语句来说，一般来说，就是检查两件事：<strong>错误</strong> 和 <strong>状态</strong>。</p>
<p>检查错误</p>
<p>对于检查错误来说，使用 Guard Clauses 会是一种标准解，但我们还需要注意下面几件事：</p>
<p>1）当然，出现错误的时候，还会出现需要释放资源的情况。你可以使用 <code>goto fail</code>; 这样的方式，但是最优雅的方式应该是C++面向对象式的 RAII 方式。</p>
<p>2）以错误码返回是一种比较简单的方式，这种方式有很一些问题，比如，如果错误码太多，判断出错的代码会非常复杂，另外，正常的代码和错误的代码会混在一起，影响可读性。所以，在更为高组的语言中，使用<code>try-catch</code>异常捕捉的方式，会让代码更为易读一些。</p>
<p><strong>检查状态</strong></p>
<p>对于检查状态来说，实际中一定有更为复杂的情况，比如下面几种情况：</p>
<p>1）像TCP协议中的两端的状态变化。</p>
<p>2）像shell各个命令的命令选项的各种组合。</p>
<p>3）像游戏中的状态变化（一棵非常复杂的状态树）。</p>
<p>4）像语法分析那样的状态变化。</p>
<p>对于这些复杂的状态变化，其本上来说，你需要先定义一个状态机，或是一个子状态的组合状态的查询表，或是一个状态查询分析树。</p>
<p><strong>写代码时，代码的运行中的控制状态或业务状态是会让你的代码流程变得混乱的一个重要原因，重构“箭头型”代码的一个很重要的工作就是重新梳理和描述这些状态的变迁关系。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，下面总结一下，把“箭头型”代码重构掉的几个手段如下：</p>
<p>1）<strong>使用 Guard Clauses</strong> 。 尽可能的让出错的先返回， 这样后面就会得到干净的代码。</p>
<p>2）<strong>把条件中的语句块抽取成函数</strong>。 有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护，<strong>写出让人易读易维护的代码才是重构代码的初衷</strong>！</p>
<p>3）<strong>对于出错处理，使用try-catch异常处理和RAII机制</strong>。返回码的出错处理有很多问题，比如：A) 返回码可以被忽略，B) 出错处理的代码和正常处理的代码混在一起，C) 造成函数接口污染，比如像atoi()这种错误码和返回值共用的糟糕的函数。</p>
<p>4）对于多个状态的判断和组合，如果复杂了，可以使用“组合状态表”，或是状态机加Observer的状态订阅的设计模式。这样的代码即解了耦，也干净简单，同样有很强的扩展性。</p>
<p>5） 重构“箭头型”代码其实是在帮你重新梳理所有的代码和逻辑，这个过程非常值得为之付出。重新整思路去想尽一切办法简化代码的过程本身就可以让人成长。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/重构/">重构</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/重构/">重构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/10/流式计算概述和Spark-Streaming-tips/" title="流式计算概述和Spark Streaming tips" itemprop="url">流式计算概述和Spark Streaming tips</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-04-10T08:05:54.000Z" itemprop="datePublished"> 發表於 2017-04-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="常规计算引擎分类"><a href="#常规计算引擎分类" class="headerlink" title="常规计算引擎分类"></a>常规计算引擎分类</h2><ol>
<li>批处理<br>• 高吞吐，低延迟<br>• 面向静态数据集合的处理<br>• 分钟甚至小时级别延迟<br>• 比如MR, Spark</li>
<li>流式计算<br>• 面向行级别数据处理<br>• 毫秒级延迟<br>• 比如storm</li>
</ol>
<h2 id="流式计算分类"><a href="#流式计算分类" class="headerlink" title="流式计算分类"></a>流式计算分类</h2><ol>
<li>面向行<br>Apache Flink — 收集一堆数据，然后一行一行处理<br>Storm</li>
<li>面向micro-Batch<br>Spark Streaming — 收集一堆数据，然后一起处理 </li>
</ol>
<h2 id="流式计算通用户环节"><a href="#流式计算通用户环节" class="headerlink" title="流式计算通用户环节"></a>流式计算通用户环节</h2><p>数据源 —&gt; 数据缓存 —&gt; 流式引擎 —&gt; 结果存储</p>
<h2 id="流式计算计算方式"><a href="#流式计算计算方式" class="headerlink" title="流式计算计算方式"></a>流式计算计算方式</h2><ol>
<li>固定窗口<br>Spark Streaming 常规支持的方式</li>
<li><p>滑动窗口( window )</p>
</li>
<li><p>会话计算( mapWithStates )<br>存储Spark Streaming的状态信息（类似session），可以进行过期处理</p>
<h2 id="Spark-Streaming编程要点"><a href="#Spark-Streaming编程要点" class="headerlink" title="Spark Streaming编程要点"></a>Spark Streaming编程要点</h2></li>
</ol>
<blockquote>
<p>Spark Streaming: exactly once delivery<br>特殊情况：故障重算，推测执行等</p>
</blockquote>
<ol>
<li>Monitoring and managing jobs</li>
</ol>
<ul>
<li>where to run the driver?<br><strong>Yarn cluster mode</strong>. Driver will continue to running when the client machine goes down.</li>
<li>How to restart driver ?<br>set up <strong>automatic restart</strong>.<br>In spark configuration (e.g. spark-defaults.conf): </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark.yarn.maxAppAttempts=2  // 重试尝试次数</span><br><span class="line">spark.yarn.am.attemptFailuresValidityInterval=1h  // 重置尝试次数的时间</span><br><span class="line">spark.yarn.max.executor.failures=&#123;8 * num_executors&#125;  // executor失败的最大次数</span><br><span class="line">spark.yarn.executor.failuresValidityInterval=1h	// 重置失败的时间</span><br><span class="line">spark.task.maxFailures=8   // task重试次数 默认是4</span><br><span class="line">spark.speculation=true  //预测执行， 前提：task是幂等</span><br></pre></td></tr></table></figure>
<ul>
<li>Summary<br>各种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2. Graceful shutting down your streaming app</span><br><span class="line">思路： Thread hooks – Check for an external flag every N seconds</span><br><span class="line"> </span><br><span class="line">``` scala</span><br><span class="line">/** * Stop the execution of the streams, with option of ensuring all received data </span><br><span class="line">	* has been processed. </span><br><span class="line">	*</span><br><span class="line">	* * @param stopSparkContext if true, stops the associated SparkContext. The underlying SparkContext </span><br><span class="line">	* will be stopped regardless of whether this StreamingContext has been </span><br><span class="line">	* started. </span><br><span class="line">	* @param stopGracefully if true, stops gracefully by waiting for the processing of all </span><br><span class="line">	* received data to be completed </span><br><span class="line">	*/ </span><br><span class="line">	def stop(stopSparkContext: Boolean, stopGracefully: Boolean): Unit = &#123;</span><br><span class="line">	receiverTracker.stop(processAllReceivedData) //default is to wait 10 second, grace waits until done jobGenerator.stop(processAllReceivedData) // Will use spark.streaming.gracefulStopTimeout </span><br><span class="line">	jobExecutor.shutdown() </span><br><span class="line">	val terminated = if (processAllReceivedData) &#123; </span><br><span class="line">		jobExecutor.awaitTermination(1, TimeUnit.HOURS) // just a very large period of time </span><br><span class="line">	&#125; else &#123; </span><br><span class="line">		jobExecutor.awaitTermination(2, TimeUnit.SECONDS) </span><br><span class="line">	&#125; </span><br><span class="line">	if (!terminated) &#123; jobExecutor.shutdownNow() </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>How to be graceful?<br>• cmd line<br>– $SPARK_HOME_DIR/bin/spark-submit –master $MASTER_REST_URL –kill $DRIVER_ID<br>– spark.streaming.stopGracefullyOnShutdown=true </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">stopOnShutdown</span></span>(): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> stopGracefully = conf.getBoolean(<span class="string">"spark.streaming.stopGracefullyOnShutdown"</span>, <span class="literal">false</span>) </span><br><span class="line">logInfo(<span class="string">s"Invoking stop(stopGracefully=<span class="subst">$stopGracefully</span>) from shutdown hook"</span>) </span><br><span class="line"><span class="comment">// Do not stop SparkContext, let its own shutdown hook stop it </span></span><br><span class="line">stop(stopSparkContext = <span class="literal">false</span>, stopGracefully = stopGracefully) &#125;</span><br></pre></td></tr></table></figure>
<p>• By marker file<br>– Touch a file when starting the app on HDFS<br>– Remove the file when you want to stop<br>– Separate thread in Spark app, calls </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamingContext.stop(stopSparkContext = <span class="literal">true</span>, stopGracefully = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark-Streaming/">Spark Streaming</a><a href="/tags/流式计算/">流式计算</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/06/Structured-Streaming介绍/" title="Structured Streaming介绍" itemprop="url">Structured Streaming介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-04-06T05:42:35.000Z" itemprop="datePublished"> 發表於 2017-04-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="中文入门编程指南"><a href="#中文入门编程指南" class="headerlink" title="中文入门编程指南"></a><a href="https://www.iteblog.com/archives/2084.html" target="_blank" rel="external">中文入门编程指南</a></h2><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="external">官方文档</a></h2><h2 id="Real-time-Streaming-ETL-with-Structured-Streaming-in-Apache-Spark-2-1"><a href="#Real-time-Streaming-ETL-with-Structured-Streaming-in-Apache-Spark-2-1" class="headerlink" title="Real-time Streaming ETL with Structured Streaming in Apache Spark 2.1"></a><a href="https://databricks.com/blog/2017/01/19/real-time-streaming-etl-structured-streaming-apache-spark-2-1.html" target="_blank" rel="external">Real-time Streaming ETL with Structured Streaming in Apache Spark 2.1</a></h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Structured Streaming接口在社区2.0版本发布测试接口，主要暴露最初的设计思路及基本接口，不具备在生产环境使用的能力；2.1版本中Structured Streaming作为主要功能发布，支持Kafka数据源、基于event_time的window及watermark功能，虽然还在Alapha阶段，但从实现的完备程度及反馈来看已具备初步的功能需求。</p>
<h2 id="设计理念及所解决的问题"><a href="#设计理念及所解决的问题" class="headerlink" title="设计理念及所解决的问题"></a>设计理念及所解决的问题</h2><p>从Spark 0.7版本发布DStream接口及Spark Streaming模块以来，Spark具备流式处理功能且在业界有了一系列应用，但依旧存在一些问题，诟病较多的是如下几点：</p>
<ul>
<li>不支持event_time，按照到达绝对时间切分records组成DStream的方式对很多场景不适合</li>
<li>不支持流式window操作</li>
<li>不支持watermark，无法对乱序数据做容错</li>
</ul>
<p>2.1版本的Spark不但解决上述问题，并将Spark Streaming的流处理方式和1.x版本中集中开发的SQL模块、DataFrame\DataSet API相融合，推出Structured Streaming引擎。其设计思路在于将持续不断的上游数据抽象为unbounded table，对流式的处理看作是表中不同部分的数据(complete\append\update mode)进行处理：<br><img src="http://spark.apache.org/docs/latest/img/structured-streaming-stream-as-a-table.png" alt=""><br>从代码层面看，Structured Streaming代码放在sql模块中，与原有SQL的datasource api、logical plan、physical plan做了诸多兼容操作，将流式处理的上游下游分别抽象为Source与Sink，基于DataFrame抽象出输入输出流DataStreamReader、DataStreamWriter。DataStreamReader中打通datasource api，支持多种上游的读取支持，DataStreamWriter中遵循惰性计算的思路实现多种触发操作及不同类型的写出模式。</p>
<h2 id="Demo-for-struct-streaming"><a href="#Demo-for-struct-streaming" class="headerlink" title="Demo for struct streaming"></a>Demo for struct streaming</h2><p>一个完整的struct streaming示例及分布解释如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 与其他spark作业一致，获取build spark session,对应旧版本中的spark context</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">  .builder</span><br><span class="line">  .appName(<span class="string">"StructuredNetworkWordCount"</span>)</span><br><span class="line">  .getOrCreate()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="comment">// 创建一个基于stream source的dataframe</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> lines = spark.readStream</span><br><span class="line">  .format(<span class="string">"socket"</span>)    # 对应基本概念：<span class="type">Source</span></span><br><span class="line">  .option(<span class="string">"host"</span>, host)</span><br><span class="line">  .option(<span class="string">"port"</span>, port)</span><br><span class="line">  .load()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// WordCount逻辑，与dataframe/dataset api用法完全一致，</span></span><br><span class="line"><span class="keyword">val</span> words = lines.as[<span class="type">String</span>].flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordCounts = words.groupBy(<span class="string">"value"</span>).count()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用dataset的writeStream创建写出流，设置对应的sink mode及类型</span></span><br><span class="line"><span class="keyword">val</span> query = wordCounts.writeStream</span><br><span class="line">  .outputMode(<span class="string">"complete"</span>)   # 对应基本概念：<span class="type">Output</span> <span class="type">Mode</span></span><br><span class="line">  .format(<span class="string">"console"</span>)        # 对应基本概念：<span class="type">Sink</span></span><br><span class="line">  .start()</span><br><span class="line"> </span><br><span class="line">query.awaitTermination()</span><br></pre></td></tr></table></figure></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Struct Streaming的输入源，每种输入源对应自己的dataSource实现，当前支持如下三种Source：</p>
<ul>
<li><strong>File Source</strong>: 输入数据源为hdfs目录中的文件，天然支持的文件格式和dataset一致(json csv text parquet)，将文件不断mv至指定目录中作为持续数据源</li>
<li><strong>Kafka Source</strong>: 将kafka作为struct streaming source，目前支持的版本为0.10.0</li>
<li><strong>Socket Source</strong>: 将socket输入数据作为streaming source，只用来做调试和demo使用<h3 id="Output-Mode"><a href="#Output-Mode" class="headerlink" title="Output Mode"></a>Output Mode</h3>Output Mode都是对于每次trigger过后的result table而言的</li>
<li><strong>Complete Mode</strong> : 从开始到目前为止的所有数据视为一张大表，query作用于整个表上的结果整体写入</li>
<li><strong>Append Mode</strong> : 从上次trigger到目前为止，不会在发生变化的数据append到最终的sink端</li>
<li><strong>Update Mode</strong> : 从上次trigger到目前为止，发生变化的条目写入到最终的sink端</li>
</ul>
<p>简单用自带的StructuredNetworkWordCountWindowed实例对比下Complete mode与Update Mode:<br>数据输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[liyuanjian@MacBook~Pro ~]$ nc -l 9999</span><br><span class="line">apache spark</span><br><span class="line">apache hadoop</span><br><span class="line">baidu inf spark</span><br></pre></td></tr></table></figure></p>
<p>Complete mode output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache| 1|</span><br><span class="line">| spark| 1|</span><br><span class="line">+------+-----+</span><br><span class="line"> </span><br><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache| 2|</span><br><span class="line">|hadoop| 1|</span><br><span class="line">| spark| 1|</span><br><span class="line">+------+-----+</span><br><span class="line"> </span><br><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">| baidu| 1|</span><br><span class="line">|apache| 2|</span><br><span class="line">|hadoop| 1|</span><br><span class="line">| spark| 2|</span><br><span class="line">| inf| 1|</span><br><span class="line">+------+-----+</span><br></pre></td></tr></table></figure></p>
<p>Update mode output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache| 1|</span><br><span class="line">| spark| 1|</span><br><span class="line">+------+-----+</span><br><span class="line"> </span><br><span class="line">+------+-----+</span><br><span class="line">| value|count|</span><br><span class="line">+------+-----+</span><br><span class="line">|apache| 2|</span><br><span class="line">|hadoop| 1|</span><br><span class="line">+------+-----+</span><br><span class="line"> </span><br><span class="line">+-----+-----+</span><br><span class="line">|value|count|</span><br><span class="line">+-----+-----+</span><br><span class="line">|baidu| 1|</span><br><span class="line">| inf| 1|</span><br><span class="line">|spark| 2|</span><br><span class="line">+-----+-----+</span><br></pre></td></tr></table></figure></p>
<h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><p>作为struct streaming的下游抽象，sink代表将最终处理完成的dataframe写出的方式，目前支持：</p>
<ol>
<li><strong>File sink</strong> : 将数据写入hdfs目录，可以支持带partition的table写入</li>
<li><strong>Console sink</strong> : 将数据直接调用dataframe.show()打印在stdout，调试作用，demo中使用的都是console sink</li>
<li><strong>Memory sink</strong> : 将所有下游存储在driver的内存中，抽象为一张表，也只能做调试使用</li>
<li><strong>Foreach sink</strong> : 依赖用户实现ForeachWriter接口配合使用，foreach sink中对每次触发的dataframe，按逐个partition调用ForeachWriter的接口进行处理，可以实现ForeachWriter写入任何需要的下游存储或处理系统，接口如下：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachWriter</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Move this to org.apache.spark.sql.util or consolidate this with batch API.</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Called when starting to process one partition of new data in the executor. The `version` is</span><br><span class="line">   * for data deduplication when there are failures. When recovering from a failure, some data may</span><br><span class="line">   * be generated multiple times but they will always have the same version.</span><br><span class="line">   *</span><br><span class="line">   * If this method finds using the `partitionId` and `version` that this partition has already been</span><br><span class="line">   * processed, it can return `false` to skip the further data processing. However, `close` still</span><br><span class="line">   * will be called for cleaning up resources.</span><br><span class="line">   *</span><br><span class="line">   * @param partitionId the partition id.</span><br><span class="line">   * @param version a unique id for data deduplication.</span><br><span class="line">   * @return `true` if the corresponding partition and version id should be processed. `false`</span><br><span class="line">   *         indicates the partition should be skipped.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(partitionId: <span class="type">Long</span>, version: <span class="type">Long</span>): <span class="type">Boolean</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Called to process the data in the executor side. This method will be called only when `open`</span><br><span class="line">   * returns `true`.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(value: <span class="type">T</span>): <span class="type">Unit</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Called when stopping to process one partition of new data in the executor side. This is</span><br><span class="line">   * guaranteed to be called either `open` returns `true` or `false`. However,</span><br><span class="line">   * `close` won't be called in the following cases:</span><br><span class="line">   *  - JVM crashes without throwing a `Throwable`</span><br><span class="line">   *  - `open` throws a `Throwable`.</span><br><span class="line">   *</span><br><span class="line">   * @param errorOrNull the error thrown during processing data or null if there was no error.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(errorOrNull: <span class="type">Throwable</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>和其他流式系统一样，基于滑动时间窗的数据统计、聚合是必不可少的需求，2.1实现了基于event-time的window定义，接口如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Bucketize rows into one or more time windows given a timestamp specifying column. Window</span><br><span class="line"> * starts are inclusive but the window ends are exclusive, e.g. 12:05 will be in the window</span><br><span class="line"> * [12:05,12:10) but not in [12:00,12:05). Windows can support microsecond precision. Windows in</span><br><span class="line"> * the order of months are not supported. The windows start beginning at 1970-01-01 00:00:00 UTC.</span><br><span class="line"> * The following example takes the average stock price for a one minute window every 10 seconds:</span><br><span class="line"> *</span><br><span class="line"> * &#123;&#123;&#123;</span><br><span class="line"> *   val df = ... // schema =&gt; timestamp: TimestampType, stockId: StringType, price: DoubleType</span><br><span class="line"> *   df.groupBy(window($"time", "1 minute", "10 seconds"), $"stockId")</span><br><span class="line"> *     .agg(mean("price"))</span><br><span class="line"> * &#125;&#125;&#125;</span><br><span class="line"> *</span><br><span class="line"> * The windows will look like:</span><br><span class="line"> *</span><br><span class="line"> * &#123;&#123;&#123;</span><br><span class="line"> *   09:00:00-09:01:00</span><br><span class="line"> *   09:00:10-09:01:10</span><br><span class="line"> *   09:00:20-09:01:20 ...</span><br><span class="line"> * &#125;&#125;&#125;</span><br><span class="line"> *</span><br><span class="line"> * For a streaming query, you may use the function `current_timestamp` to generate windows on</span><br><span class="line"> * processing time.</span><br><span class="line"> *</span><br><span class="line"> * @param timeColumn The column or the expression to use as the timestamp for windowing by time.</span><br><span class="line"> *                   The time column must be of TimestampType.</span><br><span class="line"> * @param windowDuration A string specifying the width of the window, e.g. `10 minutes`,</span><br><span class="line"> *                       `1 second`. Check [[org.apache.spark.unsafe.types.CalendarInterval]] for</span><br><span class="line"> *                       valid duration identifiers. Note that the duration is a fixed length of</span><br><span class="line"> *                       time, and does not vary over time according to a calendar. For example,</span><br><span class="line"> *                       `1 day` always means 86,400,000 milliseconds, not a calendar day.</span><br><span class="line"> * @param slideDuration A string specifying the sliding interval of the window, e.g. `1 minute`.</span><br><span class="line"> *                      A new window will be generated every `slideDuration`. Must be less than</span><br><span class="line"> *                      or equal to the `windowDuration`. Check</span><br><span class="line"> *                      [[org.apache.spark.unsafe.types.CalendarInterval]] for valid duration</span><br><span class="line"> *                      identifiers. This duration is likewise absolute, and does not vary</span><br><span class="line"> *                     according to a calendar.</span><br><span class="line"> *</span><br><span class="line"> * @group datetime_funcs</span><br><span class="line"> * @since 2.0.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Experimental</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Evolving</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window</span></span>(timeColumn: <span class="type">Column</span>, windowDuration: <span class="type">String</span>, slideDuration: <span class="type">String</span>): <span class="type">Column</span> = &#123;</span><br><span class="line">  window(timeColumn, windowDuration, slideDuration, <span class="string">"0 second"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>window通常与groupBy算子连用，通过设置dataframe中的timeColumn，windowDuration(window大小)，sildeDuration(步长)，来定义整个window的行为，如windowDuration = 10min, slideDuration = 5min，则代表由event-time触发每5分钟计算一次，计算的对象是当前window中10min的数据</p>
<h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><p>接上述window的介绍，对于任何基于window\event-time的聚合场景，我们都需要考虑对于乱序的过期event-time数据到达的处理行为。watermark用来给用户提供一个接口，让用户能够定义”比当前处理时间慢多久的数据可以丢弃，不再处理”，祥设文档参见：<a href="https://docs.google.com/document/d/1z-Pazs5v4rA31azvmYhu4I5xwqaNQl6ZLIS03xhkfCQ/edit#heading=h.yx3tjr1mrnl2" target="_blank" rel="external">https://docs.google.com/document/d/1z-Pazs5v4rA31azvmYhu4I5xwqaNQl6ZLIS03xhkfCQ/edit#heading=h.yx3tjr1mrnl2</a></p>
<p><img src="http://spark.apache.org/docs/latest/img/structured-streaming-watermark.png" alt=""></p>
<ul>
<li>watermark的计算规则</li>
</ul>
<ol>
<li>在每次trigger触发计算时，先找到trigger data中的最大(近)event-time</li>
<li>trigger结束后，   <code>new watermark = MAX(event-time before trigger, max event-time in trigger[步骤1]) - threashold</code><br>watermark的限制<br>watermark操作只能在logical plan中有一个，而且只能应用在从sink出发的单child关系链，简单理解就是处理不了复杂的多留join、union的各自设置watermark</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a><a href="/tags/Streaming/">Streaming</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/30/如何在Spark平台搭建ThriftServer/" title="如何在Spark平台搭建ThriftServer" itemprop="url">如何在Spark平台搭建ThriftServer</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-03-30T02:58:04.000Z" itemprop="datePublished"> 發表於 2017-03-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Thrift-JDBC-Server描述"><a href="#Thrift-JDBC-Server描述" class="headerlink" title="Thrift JDBC Server描述"></a>Thrift JDBC Server描述</h2><p>Thrift JDBC Server使用的是HIVE0.12的HiveServer2实现。能够使用Spark或者hive0.12版本的beeline脚本与JDBC Server进行交互使用。Thrift JDBC Server默认监听端口是10000。</p>
<h2 id="使用Thrift-JDBC-Server前需要注意："><a href="#使用Thrift-JDBC-Server前需要注意：" class="headerlink" title="使用Thrift JDBC Server前需要注意："></a>使用Thrift JDBC Server前需要注意：</h2><p>1、将<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说明: hive-site.xml配置有meta信息存储的MySQL路径</span><br><span class="line"></span><br><span class="line">2、需要在$SPARK_HOME/conf/spark-env.sh中的SPARK_CLASSPATH添加jdbc驱动的jar包</span><br><span class="line">export SPARK_CLASSPATH=$SPARK_CLASSPATH:/home/hadoop/software/mysql-connector-java-5.1.27-bin.jar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Thrift JDBC Server/beeline启动</span><br><span class="line"></span><br><span class="line">1. 启动Thrift JDBC Server：默认端口是10000</span><br><span class="line"></span><br><span class="line">cd $SPARK_HOME/sbin</span><br><span class="line">start-thriftserver.sh</span><br><span class="line">&gt; 如何修改Thrift JDBC Server的默认监听端口号？借助于--hiveconf</span><br><span class="line">start-thriftserver.sh  --hiveconf hive.server2.thrift.port=14000</span><br><span class="line"></span><br><span class="line">Demo:</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">./sbin/start-thriftserver.sh \</span><br><span class="line">        --hiveconf hive.exec.mode.local.auto=true  \</span><br><span class="line">        --hiveconf hive.auto.convert.join=true     \</span><br><span class="line">        --hiveconf hive.mapjoin.smalltable.filesize=50000000 \</span><br><span class="line">        --name thriftserver    \</span><br><span class="line">        --master yarn-client \</span><br><span class="line">        --driver-cores    5   \</span><br><span class="line">        --driver-memory   5G  \</span><br><span class="line">        --conf spark.serializer=org.apache.spark.serializer.KryoSerializer \</span><br><span class="line">        --conf spark.scheduler.mode=FAIR \</span><br><span class="line">        --conf spark.kryoserializer.buffer.max.mb=1024 \</span><br><span class="line">        --conf spark.storage.memoryFraction=0.2</span><br></pre></td></tr></table></figure></p>
<ol>
<li>启动beeline<br>cd $SPARK_HOME/bin<br>beeline -u jdbc:hive2://hadoop000:10000</li>
</ol>
<p>Demo:</p>
<pre><code class="shell">$ ./bin/beeline
Beeline version 1.2.1.spark2 by Apache Hive
beeline&gt; !connect jdbc:hive2://localhost:10000
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a><a href="/tags/ThriftServer/">ThriftServer</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/29/Scala代码规范/" title="Scala代码规范" itemprop="url">Scala代码规范</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-03-29T10:00:07.000Z" itemprop="datePublished"> 發表於 2017-03-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="格式与命名"><a href="#格式与命名" class="headerlink" title="格式与命名"></a>格式与命名</h2><p>1) 代码格式<br>用两个空格缩进。避免每行长度超过100列。在两个方法、类、对象定义之间使用一个空白行。</p>
<p>2) 优先考虑使用val，而非var。</p>
<p>3) 当引入多个包时，使用花括号：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jxl.write.&#123;<span class="type">WritableCell</span>, <span class="type">Number</span>, <span class="type">Label</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>当引入的包超过6个时，应使用通配符_：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.scalatest.events._</span><br></pre></td></tr></table></figure></p>
<p>4) 若方法暴露为接口，则返回类型应该显式声明。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span></span>(conn: <span class="type">Connection</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  executeCommand(conn, sqlStatement) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span>(result) =&gt; result</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span>(_) =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5) 集合的命名规范<br>xs, ys, as, bs等作为某种Sequence对象的名称；<br>x, y, z, a, b作为sequence元素的名称。<br>h作为head的名称，t作为tail的名称。</p>
<p>6) 避免对简单的表达式采用花括号；<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//suggestion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Int</span>) = x * x</span><br><span class="line"></span><br><span class="line"><span class="comment">//avoid</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Int</span>) = &#123;</span><br><span class="line">     x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7) 泛型类型参数的命名虽然没有限制，但建议遵循如下规则：<br>A            代表一个简单的类型，例如List[A]<br>B, C, D      用于第2、第3、第4等类型。例如：<br>                 class List[A] {<br>                     def map<a href="f: A =&gt; B" target="_blank" rel="external">B</a>: List[B] = …<br>                 }<br> N           代表数值类型</p>
<p><strong>注意：</strong>在Java中，通常以K、V代表Map的key与value，但是在Scala中，更倾向于使用A、B代表Map的key与value。</p>
<h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><p>1) 定义隐式类时，应该将构造函数的参数声明为val。</p>
<p>2) <strong>使用for表达式；如果需要条件表达式，应将条件表达式写到for comprehension中</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//not good</span></span><br><span class="line"><span class="keyword">for</span> (file &lt;- files) &#123;</span><br><span class="line">     <span class="keyword">if</span> (hasSoundFileExtension(file) &amp;&amp; !soundFileIsLong(file)) &#123;</span><br><span class="line">        soundFiles += file</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//better</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">     file &lt;- files</span><br><span class="line">     <span class="keyword">if</span> hasSoundFileExtension(file)</span><br><span class="line">     <span class="keyword">if</span> !soundFileIsLong(file)</span><br><span class="line">&#125; <span class="keyword">yield</span> file</span><br></pre></td></tr></table></figure></p>
<p><strong>通常情况下，我们应优先考虑filter, map, flatMap等操作，而非for comprehension</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//best</span></span><br><span class="line">files.filter(hasSourceFileExtension).filterNot(soundFileIsLong)</span><br></pre></td></tr></table></figure></p>
<p>3) 避免使用isInstanceOf，而是使用模式匹配，尤其是在处理比较复杂的类型判断时，使用模式匹配的可读性更好。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//avoid</span></span><br><span class="line"><span class="keyword">if</span> (x.isInstanceOf[<span class="type">Foo</span>]) &#123; do something …</span><br><span class="line"></span><br><span class="line"><span class="comment">//suggest</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPerson</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> p: <span class="type">Person</span> =&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4) 以下情况使用abstract class，而不是trait：</p>
<ul>
<li>想要创建一个需要构造函数参数的基类</li>
<li>代码可能会被Java代码调用</li>
</ul>
<p>5) <strong>如果希望trait只能被某个类（及其子类）extend，应该使用self type</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTrait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>: <span class="type">BaseType</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果希望对扩展trait的类做更多限制，可以在self type后增加更多对trait的混入：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WarpCore</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>: <span class="type">Starship</span> <span class="keyword">with</span> <span class="type">WarpCoreEjector</span> <span class="keyword">with</span> <span class="type">FireExtinguisher</span> =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this works</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enterprise</span> <span class="keyword">extends</span> <span class="title">Starship</span></span></span><br><span class="line">    <span class="keyword">with</span> <span class="type">WarpCore</span></span><br><span class="line">    <span class="keyword">with</span> <span class="type">WarpCoreEjector</span></span><br><span class="line">    <span class="keyword">with</span> <span class="type">FireExtinguisher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// won't compile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enterprise</span> <span class="keyword">extends</span> <span class="title">Starship</span></span></span><br><span class="line">     <span class="keyword">with</span> <span class="type">WarpCore</span></span><br><span class="line">     <span class="keyword">with</span> <span class="type">WarpCoreEjector</span></span><br></pre></td></tr></table></figure></p>
<p><strong>如果要限制扩展trait的类必须定义相关的方法，可以在self type中定义方法，这称之为structural type</strong>（类似动态语言的鸭子类型）:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WarpCore</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>: &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ejectWarpCore</span></span>(password: <span class="type">String</span>): <span class="type">Boolean</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">startWarpCore</span></span>: <span class="type">Unit</span></span><br><span class="line">     &#125; =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enterprise</span> <span class="keyword">extends</span> <span class="title">Starship</span> <span class="keyword">with</span> <span class="title">WarpCore</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">ejectWarpCore</span></span>(password: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">          <span class="keyword">if</span> (password == <span class="string">"password"</span>) &#123; println(<span class="string">"core ejected"</span>); <span class="literal">true</span> &#125; <span class="keyword">else</span> <span class="literal">false</span> &#125;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">startWarpCore</span> </span>&#123; println(<span class="string">"core started"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6) <strong>对于较长的类型名称，在特定上下文中，以不影响阅读性和表达设计意图为前提，建议使用类型别名</strong>，它可以帮助程序变得更简短。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentPool</span>[<span class="type">K</span>, <span class="type">V</span>] </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">type</span> <span class="title">Queue</span> </span>= <span class="type">ConcurrentLinkedQueue</span>[<span class="type">V</span>]</span><br><span class="line">   <span class="class"><span class="keyword">type</span> <span class="title">Map</span>   </span>= <span class="type">ConcurrentHashMap</span>[<span class="type">K</span>, <span class="type">Queue</span>]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7) 如果要使用隐式参数，应尽量使用自定义类型作为隐式参数的类型，而避免过于宽泛的类型，如String，Int，Boolean等。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//suggestion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxOfList</span></span>[<span class="type">T</span>](elements: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">         (<span class="keyword">implicit</span> orderer: <span class="type">T</span> =&gt; <span class="type">Ordered</span>[<span class="type">T</span>]): <span class="type">T</span> =</span><br><span class="line">   elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"empty list!"</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">         <span class="keyword">val</span> maxRest = maxListImpParm(rest)(orderer)</span><br><span class="line">         <span class="keyword">if</span> (orderer(x) &gt; maxRest) x</span><br><span class="line">         <span class="keyword">else</span> maxRest</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avoid</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxOfListPoorStyle</span></span>[<span class="type">T</span>](elements: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">        (<span class="keyword">implicit</span> orderer: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">Boolean</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure></p>
<p>8) <strong>对于异常的处理，Scala除了提供Java风格的try…catch…finally之外，还提供了allCatch.opt、Try…Success…Failure以及Either…Right…Left等风格的处理方式</strong>。其中，Try是2.10提供的语法。根据不同的场景选择不同风格：</p>
<ul>
<li><p>优先选择Try风格。Try很好地支持模式匹配，它兼具Option与Either的特点，因而既提供了集合的语义，又支持模式匹配，又提供了getOrElse()方法。同时，它还可以组合多个Try，并支持运用for combination。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> z = <span class="keyword">for</span> &#123;</span><br><span class="line">    a &lt;- <span class="type">Try</span>(x.toInt) </span><br><span class="line">    b &lt;- <span class="type">Try</span>(y.toInt)</span><br><span class="line">&#125; <span class="keyword">yield</span> a * b</span><br><span class="line"><span class="keyword">val</span> answer = z.getOrElse(<span class="number">0</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望清楚的表现非此即彼的特性，应考虑使用Either。注意，约定成俗下，我们习惯将正确的结果放在Either的右边（Right既表示右边，又表示正确）</p>
</li>
<li><p>如果希望将异常情况处理为None，则应考虑使用allCatch.opt。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Exception</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readTextFile</span></span>(f: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">List</span>[<span class="type">String</span>]] =     </span><br><span class="line">    allCatch.opt(<span class="type">Source</span>.fromFile(f).getLines.toList)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望在执行后释放资源，从而需要使用finally时，考虑try…catch…finally，或者结合try…catch…finally与Either。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">executeQuery</span></span>(conn: <span class="type">Connection</span>, sql: <span class="type">String</span>): <span class="type">Either</span>[<span class="type">SQLException</span>, <span class="type">ResultSet</span>] = &#123;</span><br><span class="line">  <span class="keyword">var</span> stmt: <span class="type">Statement</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> rs: <span class="type">ResultSet</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    stmt = conn.createStatement()</span><br><span class="line">    rs = stmt.executeQuery(sql)</span><br><span class="line">    <span class="type">Right</span>(rs)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">SQLException</span> =&gt; &#123;</span><br><span class="line">      e.printStackTrace()</span><br><span class="line">      <span class="type">Left</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (rs != <span class="literal">null</span>) rs.close()</span><br><span class="line">      <span class="keyword">if</span> (stmt != <span class="literal">null</span>) stmt.close()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">SQLException</span> =&gt; e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为避免重复，还应考虑引入Load Pattern。 </p>
<h2 id="编码模式"><a href="#编码模式" class="headerlink" title="编码模式"></a>编码模式</h2><p>1) <strong>Loan Pattern: 确保打开的资源（如文件、数据库连接）能够在操作完毕后被安全的释放</strong>。</p>
<p>Loan Pattern的通用格式如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using</span></span>[<span class="type">A</span>](r : <span class="type">Resource</span>)(f : <span class="type">Resource</span> =&gt; <span class="type">A</span>) : <span class="type">A</span> =</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        f(r)</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        r.dispose()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个格式针对Resource类型进行操作。还有一种做法是：只要实现了close方法，都可以运用Loan Pattern：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">using</span></span>[<span class="type">A</span> &lt;: <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>():<span class="type">Unit</span>, <span class="type">B</span>][resource: <span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">B</span> = </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          f(resource)</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          resource.close()</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>以FileSource为例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using(io.<span class="type">Source</span>.fromFile(<span class="string">"example.txt"</span>)) &#123; </span><br><span class="line">    source =&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (line &lt;- source.getLines) &#123;</span><br><span class="line">            println(line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2) <strong>Cake Pattern: 利用self type实现依赖注入</strong></p>
<p>例如，对于DbAccessor而言，需要提供不同的DbConnectionFactory来创建连接，从而访问不同的Data Source。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DbConnectionFactory</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">createDbConnection</span></span>: <span class="type">Connection</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SybaseDbConnectionFactory</span> <span class="keyword">extends</span> <span class="title">DbConnectionFactory…</span></span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MySQLDbConnectionFactory</span> <span class="keyword">extends</span> <span class="title">DbConnectionFactory…</span></span></span><br></pre></td></tr></table></figure></p>
<p>运用Cake Pattern，DbAccessor的定义应该为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DbAccessor</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>: <span class="type">DbConnectionFactory</span> =&gt; </span><br><span class="line"></span><br><span class="line">     <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于DbAccessor使用了self type，因此可以在DbAccessor中调用DbConnectionFactory的方法createDbConnection()。客户端在创建DbAccessor时，可以根据需要选择混入的DbConnectionFactory：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sybaseDbAccessor = <span class="keyword">new</span> <span class="type">DbAccessor</span> <span class="keyword">with</span> <span class="type">SybaseDbConnectionFactory</span></span><br></pre></td></tr></table></figure></p>
<p>当然，也可以定义object：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SybaseDbAccessor</span> <span class="keyword">extends</span> <span class="title">DbAccessor</span> <span class="keyword">with</span> <span class="title">SybaseDbConnectionFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySQLDbAccessor</span> <span class="keyword">extends</span> <span class="title">DbAccessor</span> <span class="keyword">with</span> <span class="title">MySQLDbConnectionFactory</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><p>1) <strong>尽可能直接在函数定义的地方使用模式匹配。</strong>例如，在下面的写法中，match应该被折叠起来(collapse):<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list map &#123; item =&gt;   </span><br><span class="line">     item <span class="keyword">match</span> &#123;     </span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x     </span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">default</span>   </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用下面的写法替代：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list map &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; x</span><br><span class="line">   <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">default</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它很清晰的表达了 list中的元素都被映射，间接的方式让人不容易明白。此时，<strong>传入map的函数实则为partial function</strong>。 </p>
<p>2) <strong>避免使用null，而应该使用Option的None</strong>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CopyBytes</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> in = <span class="type">None</span>: <span class="type">Option</span>[<span class="type">FileInputStream</span>]</span><br><span class="line">     <span class="keyword">var</span> out = <span class="type">None</span>: <span class="type">Option</span>[<span class="type">FileOutputStream</span>]</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          in = <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"/tmp/Test.class"</span>))</span><br><span class="line">          out = <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"/tmp/Test.class.copy"</span>))</span><br><span class="line">          <span class="keyword">var</span> c = <span class="number">0</span></span><br><span class="line">          <span class="keyword">while</span> (&#123;c = in.get.read; c != −<span class="number">1</span>&#125;) &#123;</span><br><span class="line">             out.get.write(c)</span><br><span class="line">    &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt; e.printStackTrace</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          println(<span class="string">"entered finally ..."</span>)</span><br><span class="line">          <span class="keyword">if</span> (in.isDefined) in.get.close</span><br><span class="line">          <span class="keyword">if</span> (out.isDefined) out.get.close</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法的返回值也要避免返回Null。应考虑返回Option，Either，或者Try。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.&#123;<span class="type">Try</span>, <span class="type">Success</span>, <span class="type">Failure</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readTextFile</span></span>(filename: <span class="type">String</span>): <span class="type">Try</span>[<span class="type">List</span>[<span class="type">String</span>]] = &#123; </span><br><span class="line">    <span class="type">Try</span>(io.<span class="type">Source</span>.fromFile(filename).getLines.toList</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filename = <span class="string">"/etc/passwd"</span> </span><br><span class="line">readTextFile(filename) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(lines) =&gt; lines.foreach(println)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(f) =&gt; println(f) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3) <strong>若在Class中需要定义常量，应将其定义为val，并将其放在该类的伴生对象中</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> (<span class="params">var crustSize: <span class="type">Int</span>, var crustType: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(crustSize: <span class="type">Int</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>(crustSize, <span class="type">Pizza</span>.<span class="type">DEFAULT_CRUST_TYPE</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(crustType: <span class="type">String</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>(<span class="type">Pizza</span>.<span class="type">DEFAULT_CRUST_SIZE</span>, crustType)</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() &#123;</span><br><span class="line">          <span class="keyword">this</span>(<span class="type">Pizza</span>.<span class="type">DEFAULT_CRUST_SIZE</span>, <span class="type">Pizza</span>.<span class="type">DEFAULT_CRUST_TYPE</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"A <span class="subst">$crustSize</span> inch pizza with a <span class="subst">$crustType</span> crust"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">     <span class="keyword">val</span> <span class="type">DEFAULT_CRUST_SIZE</span> = <span class="number">12</span></span><br><span class="line">     <span class="keyword">val</span> <span class="type">DEFAULT_CRUST_TYPE</span> = <span class="string">"THIN"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4) 合理为构造函数或方法提供默认值。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socket</span> (<span class="params">val timeout: <span class="type">Int</span> = 10000</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>5) 如果需要返回多个值时，应返回tuple。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStockInfo</span> </span>= &#123;</span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     (<span class="string">"NFLX"</span>, <span class="number">100.00</span>, <span class="number">101.00</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6) 作为访问器的方法，如果没有副作用，在声明时建议定义为没有括号。</p>
<p>例如，Scala集合库提供的scala.collection.immutable.Queue中，dequeue方法没有副作用，声明时就没有括号：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.immutable.<span class="type">Queue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> q = <span class="type">Queue</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> value = q.dequeue</span><br></pre></td></tr></table></figure></p>
<p>7) <strong>将包的公有代码（常量、枚举、类型定义、隐式转换等）放到package object中</strong>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.agiledon.myapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">model</span> </span>&#123;</span><br><span class="line">     <span class="comment">// field</span></span><br><span class="line">     <span class="keyword">val</span> <span class="type">MAGIC_NUM</span> = <span class="number">42</span> <span class="number">182</span> | <span class="type">Chapter</span> <span class="number">6</span>: <span class="type">Objects</span></span><br><span class="line">￼</span><br><span class="line">     <span class="comment">// method</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>(a: <span class="type">Any</span>) &#123; println(a) &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// enumeration</span></span><br><span class="line">     <span class="class"><span class="keyword">object</span> <span class="title">Margin</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">          <span class="class"><span class="keyword">type</span> <span class="title">Margin</span> </span>= <span class="type">Value</span></span><br><span class="line">          <span class="keyword">val</span> <span class="type">TOP</span>, <span class="type">BOTTOM</span>, <span class="type">LEFT</span>, <span class="type">RIGHT</span> = <span class="type">Value</span></span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// type definition</span></span><br><span class="line">     <span class="class"><span class="keyword">type</span> <span class="title">MutableMap</span>[<span class="type">K</span>, <span class="type">V</span>] </span>= scala.collection.mutable.<span class="type">Map</span>[<span class="type">K</span>, <span class="type">V</span>]</span><br><span class="line">     <span class="keyword">val</span> <span class="type">MutableMap</span> = scala.collection.mutable.<span class="type">Map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8) 建议将package object放到与包对象命名空间一致的目录下，并命名为package.scala。以model为例，package.scala文件应放在：<br>+– com<br>     +– agiledon<br>          +– myapp<br>               +– model<br>                    +– package.scala</p>
<p>9) 若有多个样例类属于同一类型，应共同继承自一个sealed trait。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Message</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetCustomers</span> <span class="keyword">extends</span> <span class="title">Message</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GetOrders</span> <span class="keyword">extends</span> <span class="title">Message</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>注</strong>：这里的sealed，表示trait的所有实现都必须声明在定义trait的文件中。</p>
<p>10) <strong>考虑使用renaming clause来简化代码。例如，替换被频繁使用的长名称方法</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">System</span>.out.&#123;println =&gt; p&#125;</span><br><span class="line"></span><br><span class="line">p(<span class="string">"hallo scala"</span>)</span><br><span class="line">p(<span class="string">"input"</span>)</span><br></pre></td></tr></table></figure></p>
<p>11) <strong>在遍历Map对象或者Tuple的List时，且需要访问map的key和value值时，优先考虑采用Partial Function</strong>，而非使用_1和_2的形式。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dollar = <span class="type">Map</span>(<span class="string">"China"</span> -&gt; <span class="string">"CNY"</span>, <span class="string">"US"</span> -&gt; <span class="string">"DOL"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//perfer</span></span><br><span class="line">dollar.foreach &#123;</span><br><span class="line">     <span class="keyword">case</span> (country, currency) =&gt; println(<span class="string">s"<span class="subst">$country</span> -&gt; <span class="subst">$currency</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avoid</span></span><br><span class="line">dollar.foreach ( x =&gt; println(<span class="string">s"<span class="subst">$x</span>._1 -&gt; <span class="subst">$x</span>._2"</span>) )</span><br></pre></td></tr></table></figure></p>
<p>或者，考虑使用for comprehension：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((country, currency) &lt;- dollar) println(<span class="string">s"<span class="subst">$country</span> -&gt; <span class="subst">$currency</span>"</span>)</span><br></pre></td></tr></table></figure></p>
<p>12) 遍历集合对象时，如果需要获得并操作集合对象的下标，不要使用如下方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="type">List</span>(<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> until l.length) <span class="keyword">yield</span> (i, l(i))</span><br></pre></td></tr></table></figure></p>
<p>而应该使用zipWithIndex方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((number, index) &lt;- l.zipWithIndex) <span class="keyword">yield</span> (index, number)</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l.zipWithIndex.map(x =&gt; (x._2, x._1))</span><br></pre></td></tr></table></figure></p>
<p>当然，如果需要将索引值放在Tuple的第二个元素，就更方便了。直接使用zipWithIndex即可。</p>
<p>zipWithIndex的索引初始值为0，如果想指定索引的初始值，可以使用zip：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l.zip(<span class="type">Stream</span> from <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>13) 应尽量定义小粒度的trait，然后再以混入的方式继承多个trait。例如ScalaTest中的FlatSpec：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlatSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpecLike</span> ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FlatSpecLike</span> <span class="keyword">extends</span> <span class="title">Suite</span> <span class="keyword">with</span> <span class="title">ShouldVerb</span> <span class="keyword">with</span> <span class="title">MustVerb</span> <span class="keyword">with</span> <span class="title">CanVerb</span> <span class="keyword">with</span> <span class="title">Informing</span> <span class="title">…</span></span></span><br></pre></td></tr></table></figure></p>
<p>小粒度的trait既有利于重用，同时还有利于对业务逻辑进行单元测试，尤其是当一部分逻辑需要依赖外部环境时，可以运用“关注点分离”的原则，将不依赖于外部环境的逻辑分离到单独的trait中。</p>
<p>14) 优先使用不可变集合。如果确定要使用可变集合，应明确的引用可变集合的命名空间。不要用使用import scala.collection.mutable._；然后引用 Set，应该用下面的方式替代：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collections.mutable</span><br><span class="line"><span class="keyword">val</span> set = mutable.<span class="type">Set</span>()</span><br></pre></td></tr></table></figure></p>
<p>这样更明确在使用一个可变集合。</p>
<p>15) 在自己定义的方法和构造函数里，应适当的接受最宽泛的集合类型。通常可以归结为一个: Iterable, Seq, Set, 或 Map。如果你的方法需要一个 sequence，使用 Seq[T]，而不是List[T]。这样可以分离集合与它的实现，从而达成更好的可扩展性。</p>
<p>16) <strong>应谨慎使用流水线转换的形式。当流水线转换的逻辑比较复杂时，应充分考虑代码的可读性，准确地表达开发者的意图，而不过分追求函数式编程的流水线转换风格。</strong>例如，我们想要从一组投票结果(语言，票数)中统计不同程序语言的票数并按照得票的顺序显示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> votes = <span class="type">Seq</span>((<span class="string">"scala"</span>, <span class="number">1</span>), (<span class="string">"java"</span>, <span class="number">4</span>), (<span class="string">"scala"</span>, <span class="number">10</span>), (<span class="string">"scala"</span>, <span class="number">1</span>), (<span class="string">"python"</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">val</span> orderedVotes = votes</span><br><span class="line">   .groupBy(_._1)</span><br><span class="line">   .map &#123; <span class="keyword">case</span> (which, counts) =&gt;</span><br><span class="line">     (which, counts.foldLeft(<span class="number">0</span>)(_ + _._2))</span><br><span class="line">   &#125;.toSeq</span><br><span class="line">   .sortBy(_._2)</span><br><span class="line">   .reverse</span><br></pre></td></tr></table></figure></p>
<p>上面的代码简洁并且正确，但几乎每个读者都不好理解作者的原本意图。一个策略是声明中间结果和参数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> votesByLang = votes groupBy &#123; <span class="keyword">case</span> (lang, _) =&gt; lang &#125;</span><br><span class="line"><span class="keyword">val</span> sumByLang = votesByLang map &#123; </span><br><span class="line">     <span class="keyword">case</span> (lang, counts) =&gt;</span><br><span class="line">          <span class="keyword">val</span> countsOnly = counts map &#123; <span class="keyword">case</span> (_, count) =&gt; count &#125;</span><br><span class="line">          (lang, countsOnly.sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> orderedVotes = sumByLang.toSeq</span><br><span class="line">   .sortBy &#123; <span class="keyword">case</span> (_, count) =&gt; count &#125;</span><br><span class="line">   .reverse</span><br></pre></td></tr></table></figure></p>
<p>代码也同样简洁，但更清晰的表达了转换的发生(通过命名中间值)，和正在操作的数据的结构(通过命名参数)。</p>
<p>17) 对于Options对象，如果getOrElse能够表达业务逻辑，就应避免对其使用模式匹配。许多集合的操作都提供了返回Options的方法。例如headOption等。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = list.headOption getOrElse <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这要比模式匹配更清楚：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = list <span class="keyword">match</span> </span><br><span class="line">     <span class="keyword">case</span> head::_ =&gt; head</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Nil</span>: =&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>18) <strong>当需要对两个或两个以上的集合进行操作时，应优先考虑使用for表达式</strong>，而非map，flatMap等操作。此时，for comprehension会更简洁易读。例如，获取两个字符的所有排列，相同的字符不能出现两次。使用flatMap的代码为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> chars = 'a' to 'z'</span><br><span class="line"><span class="keyword">val</span> perms = chars flatMap &#123; a =&gt;</span><br><span class="line">  chars flatMap &#123; b =&gt;</span><br><span class="line">    <span class="keyword">if</span> (a != b) <span class="type">Seq</span>(<span class="string">"%c%c"</span>.format(a, b))</span><br><span class="line">    <span class="keyword">else</span> <span class="type">Seq</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用for comprehension会更易懂：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> perms = <span class="keyword">for</span> &#123;</span><br><span class="line">   a &lt;- chars</span><br><span class="line">   b &lt;- chars</span><br><span class="line">   <span class="keyword">if</span> a != b</span><br><span class="line"> &#125; <span class="keyword">yield</span> <span class="string">"%c%c"</span>.format(a, b)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 高效编码</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) 应尽量避免让<span class="class"><span class="keyword">trait</span><span class="title">去extend一个class。因为这种做法可能会导致间接的继承多个类，从而产生编译错误。同时，还会导致继承体系的复杂度。</span> </span></span><br><span class="line">```scala</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarfleetComponent</span></span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">StarfleetWarpCore</span> <span class="keyword">extends</span> <span class="title">StarfleetComponent</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span> <span class="keyword">extends</span> <span class="title">StarfleetComponent</span> <span class="keyword">with</span> <span class="title">StarfleetWarpCore</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomulanStuff</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// won't compile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warbird</span> <span class="keyword">extends</span> <span class="title">RomulanStuff</span> <span class="keyword">with</span> <span class="title">StarfleetWarpCore</span></span></span><br></pre></td></tr></table></figure></p>
<p>2) <strong>选择使用Seq时，若需要索引下标功能，优先考虑选择Vector，若需要Mutable的集合，则选择ArrayBuffer；<br>若要选择Linear集合，优先选择List，若需要Mutable的集合，则选择ListBuffer</strong>。</p>
<p>3) 如果需要快速、通用、不变、带顺序的集合，应优先考虑使用Vector。Vector很好地平衡了快速的随机选择和快速的随机更新（函数式）操作。Vector是Scala集合库中最灵活的高效集合。一个原则是：当你对选择集合类型犹疑不定时，就应选择使用Vector。</p>
<p>需要注意的是：当我们创建了一个IndexSeq时，Scala实际上会创建Vector对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> x = <span class="type">IndexedSeq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x: <span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>4) 如果需要选择通用的可变集合，应优先考虑使用ArrayBuffer。尤其面对一个大的集合，且新元素总是要添加到集合末尾时，就可以选择ArrayBuffer。如果使用的可变集合特性更近似于List这样的线性集合，则考虑使用ListBuffer。</p>
<p>5) 如果需要将大量数据添加到集合中，建议选择使用List的prepend操作，将这些数据添加到List头部，最后做一次reverse操作。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = <span class="type">List</span>[<span class="type">Int</span>]()</span><br><span class="line">(<span class="number">1</span> to max).foreach &#123;</span><br><span class="line">     i =&gt; i +: l</span><br><span class="line">&#125;</span><br><span class="line">l.reverse</span><br></pre></td></tr></table></figure></p>
<p>6) 当一个类的某个字段在获取值时需要耗费资源，并且，该字段的值并非一开始就需要使用。则应将该字段声明为lazy。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> field = computation()</span><br></pre></td></tr></table></figure></p>
<p>7) <strong>在使用Future进行并发处理时，应使用回调的方式，而非阻塞：</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//avoid</span></span><br><span class="line"><span class="keyword">val</span> f = <span class="type">Future</span> &#123;</span><br><span class="line">     <span class="comment">//executing long time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span>.result(f, <span class="number">5</span> second)</span><br><span class="line"></span><br><span class="line"><span class="comment">//suggesion</span></span><br><span class="line"><span class="keyword">val</span> f = <span class="type">Future</span> &#123;</span><br><span class="line">     <span class="comment">//executing long time</span></span><br><span class="line">&#125;</span><br><span class="line">f.onComplete &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt; <span class="comment">//handle result</span></span><br><span class="line">     <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; e.printStackTrace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8) <strong>若有多个操作需要并行进行同步操作，可以选择使用par集合</strong>。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> urls = <span class="type">List</span>(<span class="string">"http://scala-lang.org"</span>,</span><br><span class="line">  <span class="string">"http://agiledon.github.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fromURL</span></span>(url: <span class="type">String</span>) = scala.io.<span class="type">Source</span>.fromURL(url)</span><br><span class="line">  .getLines().mkString(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">urls.par.map(fromURL(_))</span><br><span class="line">println(<span class="string">"time: "</span> + (<span class="type">System</span>.currentTimeMillis - t) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure></p>
<p>9) <strong>若有多个操作需要并行进行异步操作，则采用for comprehension对future进行join方式的执行</strong>。例如，假设Cloud.runAlgorithm()方法返回一个Futrue[Int]，可以同时执行多个runAlgorithm方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result1 = <span class="type">Cloud</span>.runAlgorithm(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> result2 = <span class="type">Cloud</span>.runAlgorithm(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">val</span> result3 = <span class="type">Cloud</span>.runAlgorithm(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> &#123;</span><br><span class="line">  r1 &lt;- result1</span><br><span class="line">  r2 &lt;- result2</span><br><span class="line">  r3 &lt;- result3</span><br><span class="line">&#125; <span class="keyword">yield</span> (r1 + r2 + r3)</span><br><span class="line">     </span><br><span class="line">result onSuccess &#123;</span><br><span class="line">  <span class="keyword">case</span> result =&gt; println(<span class="string">s"total = <span class="subst">$result</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1) 测试类应该与被测试类处于同一包下。如果使用Spec2或ScalaTest的FlatSpec等，则测试类的命名应该为：被测类名 + Spec；若使用JUnit等框架，则测试类的命名为：被测试类名 + Test</p>
<p>2) 测试含有具体实现的trait时，可以让被测试类直接继承Trait。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RecordsGenerator</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">generateRecords</span></span>(table: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]): <span class="type">List</span>[<span class="type">Record</span>] &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordsGeneratorSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">ShouldMatcher</span> <span class="keyword">with</span> <span class="title">RecordGenerator</span> </span>&#123;</span><br><span class="line">     <span class="keyword">val</span> table = <span class="type">List</span>(<span class="type">List</span>(<span class="string">"abc"</span>, <span class="string">"def"</span>), <span class="type">List</span>(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>))</span><br><span class="line">     it should <span class="string">"generate records"</span> in &#123;</span><br><span class="line">          <span class="keyword">val</span> records = generateRecords(table)</span><br><span class="line">          records.size should be(<span class="number">2</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3) 若要对文件进行测试，可以用字符串假装文件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CsvLine</span> </span>= <span class="type">String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatCsv</span></span>(source: <span class="type">Source</span>): <span class="type">List</span>[<span class="type">CsvLine</span>] = &#123;</span><br><span class="line">     source.getLines(_.replace(<span class="string">", "</span>, <span class="string">"|"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>formatCsv需要接受一个文件源，例如Source.fromFile(“testdata.txt”)。但在测试时，可以通过Source.fromString方法来生成formatCsv需要接收的Source对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it should <span class="string">"format csv lines"</span> in &#123;</span><br><span class="line">     <span class="keyword">val</span> lines = <span class="type">Source</span>.fromString(<span class="string">"abc, def, hgi\n1, 2, 3\none, two, three"</span>)</span><br><span class="line">     <span class="keyword">val</span> result = formatCsv(lines)</span><br><span class="line">     result.mkString(<span class="string">"\n"</span>) should be(<span class="string">"abc|def|hgi\n1|2|3\none|two|three"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Scala/">Scala</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Scala/">Scala</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/28/Hadoop的安全机制/" title="Hadoop的安全机制" itemprop="url">Hadoop的安全机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-03-28T09:31:00.000Z" itemprop="datePublished"> 發表於 2017-03-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Hadoop Kerberos安全机制介绍</p>
<p>参考: <a href="http://dongxicheng.org/mapreduce/hadoop-kerberos-introduction/" target="_blank" rel="external">http://dongxicheng.org/mapreduce/hadoop-kerberos-introduction/</a></p>
<p>在Hadoop1.0.0或者CDH3版本后，加入了Kerberos认证机制。使得集群中的节点就是它们所宣称的，是信赖的。Kerberos可以将认证的密钥在集群部署时事先放到可靠的节点上。集群运行时，集群内的节点使用密钥得到认证。只有被认证过节点才能正常使用。企图冒充的节点由于没有事先得到的密钥信息，无法与集群内部的节点通信。防止了恶意的使用或篡改Hadoop集群的问题，确保了Hadoop集群的可靠安全。</p>
<ul>
<li>解决服务器到服务器的认证<br>由于kerberos对集群里的所有机器都分发了keytab，相互之间使用密钥进行通信，确保不会冒充服务器的情况。集群中的机器就是它们所宣称的，是可靠的。<br>防止了用户伪装成Datanode，Tasktracker，去接受JobTracker，Namenode的任务指派。</li>
<li>解决client到服务器的认证<br>Kerberos对可信任的客户端提供认证，确保他们可以执行作业的相关操作。防止用户恶意冒充client提交作业的情况。<br>用户无法伪装成其他用户入侵到一个HDFS 或者MapReduce集群上<br>用户即使知道datanode的相关信息，也无法读取HDFS上的数据<br>用户无法发送对于作业的操作到JobTracker上</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Hadoop/">Hadoop</a><a href="/tags/安全机制/">安全机制</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/28/SparkSQL有必要坐下来聊聊Join/" title="SparkSQL有必要坐下来聊聊Join" itemprop="url">SparkSQL有必要坐下来聊聊Join</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-03-28T03:15:46.000Z" itemprop="datePublished"> 發表於 2017-03-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>转自 <a href="http://hbasefly.com/2017/03/19/sparksql-basic-join/" target="_blank" rel="external">http://hbasefly.com/2017/03/19/sparksql-basic-join/</a></p>
<p>HashJoin</p>
<p>Broadcast Hash Join</p>
<p>Shuffle Hash Join</p>
<p>Sort-Merge Join</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a><a href="/tags/SparkSQL/">SparkSQL</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="slamke" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Akka/" title="Akka">Akka<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/HDFS/" title="HDFS">HDFS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hive/" title="Hive">Hive<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Kafka/" title="Kafka">Kafka<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/ML/" title="ML">ML<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/REST/" title="REST">REST<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reactor/" title="Reactor">Reactor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Scala/" title="Scala">Scala<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spark/" title="Spark">Spark<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web/" title="Web">Web<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/多线程/" title="多线程">多线程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据仓库/" title="数据仓库">数据仓库<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/重构/" title="重构">重构<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Spark/" title="Spark">Spark<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Hive/" title="Hive">Hive<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Akka/" title="Akka">Akka<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Scala/" title="Scala">Scala<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Yarn/" title="Yarn">Yarn<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Cookie/" title="Cookie">Cookie<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Spark-Streaming/" title="Spark Streaming">Spark Streaming<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Session/" title="Session">Session<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/HDFS/" title="HDFS">HDFS<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UDF/" title="UDF">UDF<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Spark2-0/" title="Spark2.0">Spark2.0<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Junit/" title="Junit">Junit<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/REST/" title="REST">REST<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="http://slamke.blogspot.com/" target="_blank" title="我的博客">我的博客</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/slamke" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:sunke3296@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Sun Ke">Sun Ke</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
