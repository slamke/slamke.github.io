<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="雁渡寒潭 风吹疏竹">
<meta property="og:url" content="http://slamke.github.io/page/11/index.html">
<meta property="og:site_name" content="雁渡寒潭 风吹疏竹">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雁渡寒潭 风吹疏竹">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://slamke.github.io/page/11/"/>





  <title>雁渡寒潭 风吹疏竹</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雁渡寒潭 风吹疏竹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">教练，我想打篮球</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/Akka的监管和监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/Akka的监管和监控/" itemprop="url">Akka的监管和监控</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:33:13+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/04/Akka的监管和监控/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/02/04/Akka的监管和监控/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Akka的监管和监控"><a href="#Akka的监管和监控" class="headerlink" title="Akka的监管和监控"></a>Akka的监管和监控</h1><h2 id="监管和监控"><a href="#监管和监控" class="headerlink" title="监管和监控"></a>监管和监控</h2><p>在 Actor 系统 中说过，监管描述的是actor之间的依赖关系：监管者将任务委托给下属，并相应地对下属的失败状况进行响应。当一个下属出现了失败（即抛出一个异常），它自己会将自己和自己所有的下属挂起，然后向自己的监管者发送一个提示失败的消息。基于所监管的工作的性质和失败的性质，监管者可以有4种基本选择：</p>
<ol>
<li>恢复下属，保持下属当前积累的内部状态</li>
<li>重启下属，清除下属的内部状态</li>
<li>永久地停止下属</li>
<li>升级失败（沿监管树向上传递失败），由此失败自己</li>
</ol>
<blockquote>
<p>警告<br>监管相关的父-子沟通，使用了特殊的系统消息及其固有的邮箱，从而和用户消息隔离开来。这意味着，监管相关的事件相对于普通的消息没有确定的顺序关系。在一般情况下，用户不能影响正常消息和失败通知的顺序。</p>
</blockquote>
<h3 id="顶级监管者"><a href="#顶级监管者" class="headerlink" title="顶级监管者"></a>顶级监管者</h3><p><img src="http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/chapter2/guardians.png" alt="enter image description here"></p>
<p>一个actor系统在其创建过程中至少要启动三个actor，如上图所示。</p>
<ul>
<li>/user: 守护Actor</li>
</ul>
<p>这个名为”/user”的守护者，作为所有用户创建actor的父actor，可能是需要打交道最多的。使用system.actorOf()创建的actor都是其子actor。</p>
<ul>
<li>/system: 系统守护者</li>
</ul>
<p>这个特殊的守护者被引入，是为了实现正确的关闭顺序，即日志（logging）要保持可用直到所有普通actor终止，即使日志本身也是用actor实现的。</p>
<ul>
<li>/: 根守护者</li>
</ul>
<p>根守护者所谓“顶级”actor的祖父，它监督所有在Actor路径的顶级作用域中定义的特殊actor，使用发现任何Exception就终止子actor的SupervisorStrategy.stoppingStrategy策略。</p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启过程中所发生事件的精确次序是：</p>
<ol>
<li>actor被挂起（意味着它不会处理正常消息直到被恢复），并递归挂起其所有子actor</li>
<li>调用旧实例的 preRestart hook (缺省实现是向所有子actor发送终止请求并调用 postStop)</li>
<li>等待所有子actor终止（使用context.stop()）直到 preRestart 最终结束；这里所有的actor操作都是非阻塞的，最后被杀掉的子actor的终止通知会影响下一步的执行</li>
<li>再次调用原来提供的工厂生成actor的新实例</li>
<li>调用新实例的postRestart方法（其默认实现是调用preStart方法）</li>
<li>对步骤3中没有被杀死的所有子actor发送重启请求；重启的actor会遵循相同的过程， 从步骤2开始</li>
<li>恢复这个actor</li>
</ol>
<h2 id="Actor引用-路径与地址"><a href="#Actor引用-路径与地址" class="headerlink" title="Actor引用, 路径与地址"></a>Actor引用, 路径与地址</h2><h3 id="什么是Actor引用？"><a href="#什么是Actor引用？" class="headerlink" title="什么是Actor引用？"></a>什么是Actor引用？</h3><p>Actor引用是 ActorRef 的子类，其最重要的目的是支持向它所代表的actor发送消息。每个actor通过self字段来访问自己的标准（本地）引用；在给其它actor发送的消息中也缺省包含这个引用。反过来，在消息处理过程中，actor可以通过sender()方法来访问到当前消息的发送者的引用。</p>
<h3 id="什么是Actor路径"><a href="#什么是Actor路径" class="headerlink" title="什么是Actor路径?"></a>什么是Actor路径?</h3><p>由于actor是以一种严格的树形结构样式来创建的，所以沿着子actor到父actor的监管链，一直到actor系统的根存在一条唯一的actor名字序列。这个序列可以被看做是文件系统中的文件路径，所以我们称之为“路径”。就像在一些真正的文件系统中一样，也存在所谓的“符号链接”，即一个actor也许能通过不同的路径被访问到，除了原始路径外，其它的路径都涉及到对actor实际监管祖先链的某部分路径进行转换的方法。</p>
<h3 id="如何获得Actor引用？"><a href="#如何获得Actor引用？" class="headerlink" title="如何获得Actor引用？"></a>如何获得Actor引用？</h3><p>actor引用的获取方法分为两类：通过创建actor，或者通过查找actor。后一种功能又分两种：通过具体的actor路径来创建actor引用，和查询actor逻辑树。</p>
<h4 id="创建Actor"><a href="#创建Actor" class="headerlink" title="创建Actor"></a>创建Actor</h4><p>一个actor系统通常是在根守护者上使用ActorSystem.actorOf创建actor来启动，然后在创建出的actor中使用ActorContext.actorOf来展开actor树。这些方法返回的是指向新创建的actor的引用。每个actor都拥有到它的父亲，它自己和它的子actor的引用（通过ActorContext访问）。这些引用可以与消息一起被发送给别的actor，以便接收方直接回复。</p>
<h4 id="通过具体的路径来查找actor"><a href="#通过具体的路径来查找actor" class="headerlink" title="通过具体的路径来查找actor"></a>通过具体的路径来查找actor</h4><p>另外，可以使用ActorSystem.actorSelection来查找actor引用。“选择”可在已有actor与被选择的actor进行通讯的时候用到，在投递每条消息的时候都会用到查找。</p>
<p>为了获得一个绑定到指定actor生命周期的ActorRef，你需要发送一个消息，如内置的Identify信息，向指定的actor，所获得的sender()即为所求。</p>
<p>val selection = context.actorSelection(“/user/serviceA”)<br>selection.tell(new Identify(identifyId), getSelf());</p>
<p>总结: actorOf vs. actorSelection vs. actorFor</p>
<p>Note</p>
<p>以上部分所描述的细节可以简要地总结和记忆成：</p>
<p>actorOf 永远都只会创建一个新的actor，这个新的actor是actorOf所调用上下文（可以是任意一个actor或actor系统本身）的直接子actor<br>actorSelection只会在消息送达后查找已经存在的actor集合，即不会创建actor，也不会在创建选择集合时验证actor是否存在。<br>actorFor（废弃，已经被actorSelection取代） 永远都只是查找到一个已存在的actor，不会创建新的actor。</p>
<h2 id="Actor路径的顶级作用域"><a href="#Actor路径的顶级作用域" class="headerlink" title="Actor路径的顶级作用域"></a>Actor路径的顶级作用域</h2><p>在路径树的根上是根监管者，所有其他actor都可以从通过它找到；它的名字是”/“。在第二个层次上是以下这些：</p>
<ul>
<li>“/user” 是所有由用户创建的顶级actor的监管者；用 ActorSystem.actorOf创建的actor在其下。</li>
<li>“/system” 是所有由系统创建的顶级actor的监管者，如日志监听器，或由配置指定在actor系统启动时自动部署的actor。</li>
<li>“/deadLetters” 是死信actor，所有发往已经终止或不存在的actor的消息会被重定向到这里（以尽最大努力为基础：即使在本地JVM，消息也可能丢失）</li>
<li>“/temp”是所有系统创建的短时actor的监管者，例如那些在ActorRef.ask的实现中用到的actor。</li>
<li>“/remote” 是一个人造虚拟路径，用来存放所有其监管者是远程actor引用的actor。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/04/Akka Actor的创建-引用-声明周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/04/Akka Actor的创建-引用-声明周期/" itemprop="url">Akka Actor的创建&引用&声明周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-04T12:09:54+08:00">
                2016-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Akka/" itemprop="url" rel="index">
                    <span itemprop="name">Akka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/04/Akka Actor的创建-引用-声明周期/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/02/04/Akka Actor的创建-引用-声明周期/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Actor的创建-amp-引用-amp-声明周期"><a href="#Actor的创建-amp-引用-amp-声明周期" class="headerlink" title="Actor的创建&amp;引用&amp;声明周期"></a>Actor的创建&amp;引用&amp;声明周期</h1><h2 id="1-创建actor"><a href="#1-创建actor" class="headerlink" title="1.创建actor"></a>1.创建actor</h2><ul>
<li>定义一个Actor类</li>
</ul>
<p>要定义自己的Actor类，需要继承Actor并实现receive方法。receive方法需要定义一系列case语句（类型为PartialFunction[Any, Unit]）来描述你的Actor能够处理哪些消息（使用标准的Scala模式匹配），以及消息如何被处理。<br>如下例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> =&gt; log.info(<span class="string">"received test"</span>)</span><br><span class="line">    <span class="keyword">case</span> _      =&gt; log.info(<span class="string">"received unknown message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Props</li>
</ul>
<p>Props是一个用来在创建actor时指定选项的配置类，可以把它看作是不可变的，因此在创建包含相关部署信息的actor时（例如使用哪一个调度器(dispatcher)，详见下文），是可以自由共享的。以下是如何创建Props实例的示例.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> props1 = <span class="type">Props</span>[<span class="type">MyActor</span>]</span><br><span class="line"><span class="keyword">val</span> props2 = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">ActorWithArgs</span>(<span class="string">"arg"</span>)) <span class="comment">// careful, see below</span></span><br><span class="line"><span class="keyword">val</span> props3 = <span class="type">Props</span>(classOf[<span class="type">ActorWithArgs</span>], <span class="string">"arg"</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>警告<br>在另一个actor中声明一个actor是非常危险的，会打破actor的封装。永远不要将一个actor的this引用传进Props！<br>推荐做法</p>
</blockquote>
<p>在每一个Actor的伴生对象中提供工厂方法是一个好主意，这有助于保持创建合适的Props，尽可能接近actor的定义。这也避免了使用Props.apply(…)方法将采用一个“按名”（by-name）参数的缺陷，因为伴生对象的给定代码块中将不会保留包含作用域的引用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DemoActor</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create Props for an actor of this type.</span></span><br><span class="line"><span class="comment">   * @param magciNumber The magic number to be passed to this actor’s constructor.</span></span><br><span class="line"><span class="comment">   * @return a Props for creating this actor, which can then be further configured</span></span><br><span class="line"><span class="comment">   *         (e.g. calling `.withDispatcher()` on it)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(magicNumber: <span class="type">Int</span>): <span class="type">Props</span> = <span class="type">Props</span>(<span class="keyword">new</span> <span class="type">DemoActor</span>(magicNumber))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActor</span>(<span class="params">magicNumber: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; sender() ! (x + magicNumber)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeOtherActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Props(new DemoActor(42)) would not be safe</span></span><br><span class="line">  context.actorOf(<span class="type">DemoActor</span>.props(<span class="number">42</span>), <span class="string">"demo"</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用Props创建Actor</li>
</ul>
<p>Actor可以通过将Props实例传入actorOf工厂方法来创建，ActorSystem和ActorContext中都有该方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">ActorSystem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorSystem is a heavy object: create only one per application</span></span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"mySystem"</span>)</span><br><span class="line"><span class="keyword">val</span> myActor = system.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>], <span class="string">"myactor2"</span>)</span><br><span class="line">使用<span class="type">ActorSystem</span>将创建顶级actor，由actor系统提供的守护actor监管；如果使用的是actor的上下文，则创建一个该actor的子actor。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> child = context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>], name = <span class="string">"myChild"</span>)</span><br><span class="line">  <span class="comment">// plus some behavior ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐创建一个树形结构，包含子actor、孙子等等，使之符合应用的逻辑错误处理结构</p>
<ul>
<li>依赖注入</li>
</ul>
<p>如果你的actor有带参数的构造函数，则这些参数也需要成为Props的一部分，如上文所述。但有些情况下必须使用工厂方法，例如，当实际构造函数的参数由依赖注入框架决定。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">IndirectActorProducer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependencyInjector</span>(<span class="params">applicationContext: <span class="type">AnyRef</span>, beanName: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">IndirectActorProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actorClass</span> </span>= classOf[<span class="type">Actor</span>]</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">produce</span> </span>=</span><br><span class="line">    <span class="comment">// obtain fresh Actor instance from DI framework ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> actorRef = system.actorOf(</span><br><span class="line">  <span class="type">Props</span>(classOf[<span class="type">DependencyInjector</span>], applicationContext, <span class="string">"hello"</span>),</span><br><span class="line">  <span class="string">"helloBean"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="2-Actor-API"><a href="#2-Actor-API" class="headerlink" title="2.Actor API"></a>2.Actor API</h2><p>Actor trait只定义了一个抽象方法，就是上面提到的receive，用来实现actor的行为。</p>
<p><strong>如果当前actor的行为与收到的消息不匹配，则会调用 unhandled，其缺省实现是向actor系统的事件流中发布一条akka.actor.UnhandledMessage(message, sender, recipient)</strong>（将配置项akka.actor.debug.unhandled设置为on来将它们转换为实际的调试消息）。</p>
<p>另外，它还包括:</p>
<ul>
<li><strong>self引用代表本actor的ActorRef</strong></li>
<li><strong>sender引用代表最近收到消息的发送actor，通常用于下面将讲到的消息回应中</strong></li>
<li><strong>supervisorStrategy 用户可重写它来定义对子actor的监管策略</strong></li>
</ul>
<p>该策略通常在actor内声明，这样决定函数就可以访问actor的内部状态：因为失败通知作为消息发送给监管者，并像普通消息一样被处理（尽管不是正常行为），所有的值和actor变量都是可用的，以及sender引用 （报告失败的将是直接子actor；如果原始失败发生在遥远的后裔，它仍然是一次向上报告一层）。</p>
<ul>
<li>context暴露actor和当前消息的上下文信息，如：<ul>
<li>用于创建子actor的工厂方法（actorOf）</li>
<li>actor所属的系统</li>
<li>父监管者</li>
<li>所监管的子actor</li>
<li>生命周期监控</li>
<li>hotswap行为栈，见Become/Unbecome</li>
</ul>
</li>
</ul>
<h2 id="3-Actor生命周期"><a href="#3-Actor生命周期" class="headerlink" title="3.Actor生命周期"></a>3.Actor生命周期</h2><p><img src="http://udn.yyuap.com/doc/akka-doc-cn/2.3.6/scala/book/images/actor_lifecycle.png" alt="enter image description here"></p>
<p>actor系统中的路径代表一个”地方”，这里可能会被活着的actor占据。最初（除了系统初始化actor）路径都是空的。在调用actorOf()时它将为指定路径分配根据传入Props创建的一个actor化身。<strong>actor化身是由路径和一个UID标识的</strong>。重新启动只会替换有Props定义的Actor实例，但不会替换化身，因此UID保持不变。</p>
<p>当actor停止时，其化身的生命周期结束。在这一时间点上相关的生命周期事件被调用，监视该actor的actor都会获得终止通知。当化身停止后，路径可以重复使用，通过actorOf()创建一个actor。在这种情况下，除了UID不同外，新化身与老化身是相同的。</p>
<p><strong>ActorRef始终表示化身（路径和UID）而不只是一个给定的路径。因此如果actor停止，并且创建一个新的具有相同名称的actor，则指向老化身的ActorRef将不会指向新的化身。</strong></p>
<p>相对地，ActorSelection指向路径（或多个路径，如果使用了通配符），且完全不关注有没有化身占据它。因此ActorSelection 不能被监视。获取某路径下的当前化身ActorRef是可能的，只要向该ActorSelection发送Identify，如果收到ActorIdentity回应，则正确的引用就包含其中（详见通过Actor Selection确定Actor）。也可以使用ActorSelection的resolveOne方法，它会返回一个包含匹配ActorRef的Future。</p>
<ul>
<li>使用DeathWatch进行生命周期监控</li>
</ul>
<p>为了在其它actor终止时 (即永久停止，而不是临时的失败和重启)收到通知，actor可以将自己注册为其它<strong>actor在终止时所发布的Terminated消息</strong>的接收者（见停止 Actor）。这个服务是由actor系统的DeathWatch组件提供的。</p>
<p>注册一个监视器很简单：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Actor</span>, <span class="type">Props</span>, <span class="type">Terminated</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> child = context.actorOf(<span class="type">Props</span>.empty, <span class="string">"child"</span>)</span><br><span class="line">  context.watch(child) <span class="comment">// &lt;-- this is the only call needed for registration</span></span><br><span class="line">  <span class="keyword">var</span> lastSender = system.deadLetters</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"kill"</span> =&gt;</span><br><span class="line">      context.stop(child); lastSender = sender()</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`child`) =&gt; lastSender ! <span class="string">"finished"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要注意Terminated消息的产生与注册和终止行为所发生的顺序无关。特别地，即使在注册时，被观察的actor已经终止了，监视actor仍然会受到一个Terminated消息。</p>
<p>多次注册并不表示会有多个消息产生，也不保证有且只有一个这样的消息被接收到：如果被监控的actor已经生成了消息并且已经进入了队列，在这个消息被处理之前又发生了另一次注册，则会有第二个消息进入队列，因为对一个已经终止的actor的监控注册操作会立刻导致Terminated消息的产生。</p>
<p>可以使用context.unwatch(target)来停止对另一个actor生存状态的监控。即使Terminated已经加入邮箱，该操作仍有效；一旦调用unwatch，则被观察的actor的Terminated消息就都不会再被处理。</p>
<ul>
<li>启动Hook</li>
</ul>
<p>actor启动后，它的preStart方法会被立即执行。</p>
<p>override def preStart() {<br>  // registering with other actors<br>  someService ! Register(self)<br>}<br>在actor第一次创建时，将调用此方法。在重新启动期间，它被postRestart的默认实现调用，这意味着通过重写该方法，你可以选择是仅仅在初始化该actor时调用一次，还是为每次重新启动都调用。actor构造函数中的初始化代码将在每个actor实例创建的时候被调用，这也发生在每次重启时。</p>
<ul>
<li>重启Hook</li>
</ul>
<p>所有的actor都是被监管的，即与另一个使用某种失败处理策略的actor绑定在一起。如果在处理一个消息的时候抛出了异常，Actor将被重启（详见监管与监控）。这个重启过程包括上面提到的Hook：</p>
<p>要被重启的actor被通知是通过调用preRestart，包含着导致重启的异常以及触发异常的消息；如果重启并不是因为消息处理而发生的，则所携带的消息为None，例如，当一个监管者没有处理某个异常继而被其监管者重启时，或者因其兄弟节点的失败导致的重启。如果消息可用，则消息的发送者通常也可用（即通过调用sender）。</p>
<p>这个方法是用来完成清理、准备移交给新actor实例等操作的最佳位置。其缺省实现是终止所有子actor并调用postStop。</p>
<p>最初调用actorOf的工厂将被用来创建新的实例。<br>新的actor的postRestart方法被调用时，将携带着导致重启的异常信息。默认实现中，preStart被调用时，就像一个正常的启动一样。<br>actor的重启只会替换掉原来的actor对象；重启不影响邮箱的内容，所以对消息的处理将在postRestart hook返回后继续。触发异常的消息不会被重新接收。在actor重启过程中，所有发送到该actor的消息将象平常一样被放进邮箱队列中。</p>
<blockquote>
<p>警告<br>要知道失败通知与用户消息的相关顺序不是决定性的。尤其是，在失败以前收到的最后一条消息被处理之前，父节点可能已经重启其子节点了。详细信息请参见“讨论：消息顺序”。</p>
</blockquote>
<ul>
<li>终止 Hook</li>
</ul>
<p>一个Actor终止后，其postStop hook将被调用，它可以用来，例如取消该actor在其它服务中的注册。这个hook保证在该actor的消息队列被禁止后才运行，即之后发给该actor的消息将被重定向到ActorSystem的deadLetters中。</p>
<h2 id="3-通过Actor-Selection定位Actor"><a href="#3-通过Actor-Selection定位Actor" class="headerlink" title="3. 通过Actor Selection定位Actor"></a>3. 通过Actor Selection定位Actor</h2><p>如Actor引用, 路径与地址中所述，每个actor都拥有一个唯一的逻辑路径，此路径是由从actor系统的根开始的父子链构成；它还拥有一个物理路径，如果监管链包含有远程监管者，此路径可能会与逻辑路径不同。这些路径用来在系统中查找actor，例如，当收到一个远程消息时查找收件者，但是它们更直接的用处在于：actor可以通过指定绝对或相对路径（逻辑的或物理的）来查找其它的actor，并随结果获取一个ActorSelection：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will look up this absolute path</span></span><br><span class="line">context.actorSelection(<span class="string">"/user/serviceA/aggregator"</span>)</span><br><span class="line"><span class="comment">// will look up sibling beneath same supervisor</span></span><br><span class="line">context.actorSelection(<span class="string">"../joe"</span>)</span><br></pre></td></tr></table></figure></p>
<p>其中指定的路径被解析为一个java.net.URI，它以/分隔成路径段。如果路径以/开始，表示一个绝对路径，且从根监管者（”/user”的父亲）开始查找；否则是从当前actor开始。如果某一个路径段为..，会找到当前所遍历到的actor的上一级，否则则会向下一级寻找具有该名字的子actor。 必须注意的是actor路径中的..总是表示逻辑结构，即其监管者。</p>
<p><strong>一个actor selection的路径元素中可能包含通配符，从而允许向匹配模式的集合广播该条消息</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will look all children to serviceB with names starting with worker</span></span><br><span class="line">context.actorSelection(<span class="string">"/user/serviceB/worker*"</span>)</span><br><span class="line"><span class="comment">// will look up all siblings beneath same supervisor</span></span><br><span class="line">context.actorSelection(<span class="string">"../*"</span>)</span><br></pre></td></tr></table></figure></p>
<p>消息可以通过ActorSelection发送，并且在投递每条消息时 ActorSelection的路径都会被查找。如果selection不匹配任何actor，则消息将被丢弃。</p>
<p>要获得ActorSelection的ActorRef，你需要发送一条消息到selection，然后使用答复消息的sender()引用即可。有一个内置的Identify消息，所有actor会理解它并自动返回一个包含ActorRef的ActorIdentity消息。此消息被遍历到的actor特殊处理为，如果一个具体的名称查找失败（即一个不含通配符的路径没有对应的活动actor），则会生成一个否定结果。请注意这并不意味着应答消息有到达保证，它仍然是一个普通的消息。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.&#123; <span class="type">Actor</span>, <span class="type">Props</span>, <span class="type">Identify</span>, <span class="type">ActorIdentity</span>, <span class="type">Terminated</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follower</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> identifyId = <span class="number">1</span></span><br><span class="line">  context.actorSelection(<span class="string">"/user/another"</span>) ! <span class="type">Identify</span>(identifyId)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`identifyId`, <span class="type">Some</span>(ref)) =&gt;</span><br><span class="line">      context.watch(ref)</span><br><span class="line">      context.become(active(ref))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ActorIdentity</span>(`identifyId`, <span class="type">None</span>) =&gt; context.stop(self)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">active</span></span>(another: <span class="type">ActorRef</span>): <span class="type">Actor</span>.<span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`another`) =&gt; context.stop(self)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你也可以通过ActorSelection的resolveOne方法获取ActorSelection的一个ActorRef。如果存在这样的actor，它将返回一个包含匹配的ActorRef的Future。如果没有这样的actor 存在或识别没有在指定的时间内完成，它将以失败告终——akka.actor.ActorNotFound。</p>
<p>如果开启了远程调用，则远程actor地址也可以被查找:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.actorSelection(<span class="string">"akka.tcp://app@otherhost:1234/user/serviceB"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4.发送消息"></a>4.发送消息</h3><p>向actor发送消息需使用下列方法之一。</p>
<ul>
<li>!意思是“fire-and-forget”，即异步发送一个消息并立即返回。也称为tell。</li>
<li>?异步发送一条消息并返回一个Future代表一个可能的回应。也称为ask。<br>对每一个消息发送者，分别有消息顺序保证。</li>
</ul>
<blockquote>
<p>注意<br>使用ask有一些性能内涵，因为需要跟踪超时，需要有桥梁将Promise转为ActorRef，并且需要在远程情况下可访问。所以为了性能应该总选择tell，除非只能选择ask。</p>
</blockquote>
<h4 id="Tell-Fire-forget"><a href="#Tell-Fire-forget" class="headerlink" title="Tell: Fire-forget"></a>Tell: Fire-forget</h4><p>这是发送消息的推荐方式。 不会阻塞地等待消息。它拥有最好的并发性和可扩展性。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actorRef ! message</span><br></pre></td></tr></table></figure></p>
<p>如果是在一个Actor中调用 ，那么发送方的actor引用会被隐式地作为消息的sender(): ActorRef成员一起发送。目的actor可以使用它来向源actor发送回应， 使用sender() ! replyMsg。</p>
<p>如果不是从Actor实例发送的，sender成员缺省为 deadLetters actor引用。</p>
<h4 id="Ask-Send-And-Receive-Future"><a href="#Ask-Send-And-Receive-Future" class="headerlink" title="Ask: Send-And-Receive-Future"></a>Ask: Send-And-Receive-Future</h4><p>ask模式既包含actor也包含future，所以它是一种使用模式，而不是ActorRef的方法:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.pattern.&#123; ask, pipe &#125;</span><br><span class="line"><span class="keyword">import</span> system.dispatcher <span class="comment">// The ExecutionContext that will be used</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>(<span class="params">x: <span class="type">Int</span>, s: <span class="type">String</span>, d: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">Request</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">implicit</span> <span class="title">val</span> <span class="title">timeout</span> </span>= <span class="type">Timeout</span>(<span class="number">5</span> seconds) <span class="comment">// needed for `?` below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f: <span class="type">Future</span>[<span class="type">Result</span>] =</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    x &lt;- ask(actorA, <span class="type">Request</span>).mapTo[<span class="type">Int</span>] <span class="comment">// call pattern directly</span></span><br><span class="line">    s &lt;- (actorB ask <span class="type">Request</span>).mapTo[<span class="type">String</span>] <span class="comment">// call by implicit conversion</span></span><br><span class="line">    d &lt;- (actorC ? <span class="type">Request</span>).mapTo[<span class="type">Double</span>] <span class="comment">// call by symbolic name</span></span><br><span class="line">  &#125; <span class="keyword">yield</span> <span class="type">Result</span>(x, s, d)</span><br><span class="line"></span><br><span class="line">f pipeTo actorD <span class="comment">// .. or ..</span></span><br><span class="line">pipe(f) to actorD</span><br></pre></td></tr></table></figure></p>
<h3 id="5-接收消息"><a href="#5-接收消息" class="headerlink" title="5.接收消息"></a>5.接收消息</h3><p>Actor必须实现receive方法来接收消息：</p>
<p>protected def receive: PartialFunction[Any, Unit]<br>这个方法应返回一个PartialFunction，例如一个“match/case”子句，消息可以与其中的不同分支进行scala模式匹配。如下例:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> =&gt; log.info(<span class="string">"received test"</span>)</span><br><span class="line">    <span class="keyword">case</span> _      =&gt; log.info(<span class="string">"received unknown message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-终止Actor"><a href="#6-终止Actor" class="headerlink" title="6.终止Actor"></a>6.终止Actor</h3><p>通过调用ActorRefFactory（即ActorContext或ActorSystem）的stop方法来终止一个actor。通常context用来终止子actor，而 system用来终止顶级actor。实际的终止操作是异步执行的，即stop可能在actor被终止之前返回。</p>
<p>actor的终止分两步: 第一步actor将挂起对邮箱的处理，并向所有子actor发送终止命令，然后处理来自子actor的终止消息直到所有的子actor都完成终止，最后终止自己（调用postStop，清空邮箱，向DeathWatch发布Terminated，通知其监管者）。这个过程保证actor系统中的子树以一种有序的方式终止，将终止命令传播到叶子结点并收集它们回送的确认消息给被终止的监管者。如果其中某个actor没有响应（即由于处理消息用了太长时间以至于没有收到终止命令），整个过程将会被阻塞。</p>
<p>在ActorSystem.shutdown()被调用时，系统根监管actor会被终止，以上的过程将保证整个系统的正确终止。</p>
<p>postStop() hook 是在actor被完全终止以后调用的。这是为了清理资源:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>() &#123;</span><br><span class="line">  <span class="comment">// clean up some resources ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意<br>由于actor的终止是异步的，你不能马上使用你刚刚终止的子actor的名字；这会导致InvalidActorNameException。你应该 监视watch()正在终止的actor，并在Terminated最终到达后作为回应创建它的替代者。</p>
</blockquote>
<p>优雅地终止</p>
<p>如果你需要等待终止过程的结束，或者组合若干actor的终止次序，可以使用gracefulStop：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.pattern.gracefulStop</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Await</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> stopped: <span class="type">Future</span>[<span class="type">Boolean</span>] = gracefulStop(actorRef, <span class="number">5</span> seconds, <span class="type">Manager</span>.<span class="type">Shutdown</span>)</span><br><span class="line">  <span class="type">Await</span>.result(stopped, <span class="number">6</span> seconds)</span><br><span class="line">  <span class="comment">// the actor has been stopped</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// the actor wasn't stopped within 5 seconds</span></span><br><span class="line">  <span class="keyword">case</span> e: akka.pattern.<span class="type">AskTimeoutException</span> =&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Shutdown</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">Manager</span>._</span><br><span class="line">  <span class="keyword">val</span> worker = context.watch(context.actorOf(<span class="type">Props</span>[<span class="type">Cruncher</span>], <span class="string">"worker"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"job"</span> =&gt; worker ! <span class="string">"crunch"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shutdown</span> =&gt;</span><br><span class="line">      worker ! <span class="type">PoisonPill</span></span><br><span class="line">      context become shuttingDown</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shuttingDown</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"job"</span> =&gt; sender() ! <span class="string">"service unavailable, shutting down"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Terminated</span>(`worker`) =&gt;</span><br><span class="line">      context stop self</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当gracefulStop()成功返回时，actor的postStop() hook将会被执行：在postStop()结束和gracefulStop()返回之间存在happens-before边界。</p>
<p>在上面的示例中自定义的Manager.Shutdown消息是发送到目标actor来启动actor的终止过程。你可以使用PoisonPill，但之后在停止目标actor之前，你与其他actor的互动的机会有限。在postStop中，可以处理简单的清理任务。</p>
<blockquote>
<p>警告<br>请记住，actor停止和其名称被注销是彼此异步发生的独立事件。因此，在gracefulStop()返回后。你会发现其名称仍可能在使用中。为了保证正确注销，只在你控制的监管者内，并且只在响应Terminated消息时重用名称，即不是用于顶级actor。</p>
</blockquote>
<h3 id="7-Become-Unbecome"><a href="#7-Become-Unbecome" class="headerlink" title="7.Become/Unbecome"></a>7.Become/Unbecome</h3><p>升级</p>
<p>Akka支持在运行时对Actor消息循环（即其实现）进行实时替换：在actor中调用context.become方法。become要求一个PartialFunction[Any, Unit]参数作为新的消息处理实现。 被替换的代码被保存在一个栈中，可以被push和pop。</p>
<blockquote>
<p>警告<br>请注意actor被其监管者重启后将恢复其最初的行为。</p>
</blockquote>
<h3 id="8-使用PartialFunction链来扩展actor"><a href="#8-使用PartialFunction链来扩展actor" class="headerlink" title="8.使用PartialFunction链来扩展actor"></a>8.使用PartialFunction链来扩展actor</h3><p>有时在一些actor中分享共同的行为，或通过若干小的函数构成一个actor的行为是很有用的。这由于actor的receive方法返回一个Actor.Receive（PartialFunction[Any,Unit]的类型别名）而使之成为可能，多个偏函数可以使用PartialFunction#orElse链接在一起。你可以根据需要链接尽可能多的功能，但是你要牢记”第一个匹配”获胜——这在组合可以处理同一类型的消息的功能时会很重要。</p>
<p>例如，假设你有一组actor是生产者Producers或消费者Consumers，然而有时候需要actor分享这两种行为。这可以很容易实现而无需重复代码，通过提取行为的特质和并将actor的receive实现为这些偏函数的组合。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ProducerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">Actor</span> =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> producerBehavior: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GiveMeThings</span> =&gt;</span><br><span class="line">      sender() ! <span class="type">Give</span>(<span class="string">"thing"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">Actor</span> <span class="keyword">with</span> <span class="type">ActorLogging</span> =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> consumerBehavior: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> ref: <span class="type">ActorRef</span> =&gt;</span><br><span class="line">      ref ! <span class="type">GiveMeThings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Give</span>(thing) =&gt;</span><br><span class="line">      log.info(<span class="string">"Got a thing! It's &#123;&#125;"</span>, thing)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ProducerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= producerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> <span class="keyword">with</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= consumerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">ProducerBehavior</span> <span class="keyword">with</span> <span class="title">ConsumerBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= producerBehavior orElse consumerBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GiveMeThings</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Give</span>(<span class="params">thing: <span class="type">Any</span></span>)</span></span><br></pre></td></tr></table></figure></p>
<p>不同于继承，相同的模式可以通过组合实现——可以简单地通过委托的偏函数组合成receive方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2016/02/03/Hystrix学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/Hystrix学习笔记/" itemprop="url">Hystrix学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-03T17:34:18+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/03/Hystrix学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/02/03/Hystrix学习笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>学习资料：<a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></p>
<h2 id="What-Is-Hystrix-For"><a href="#What-Is-Hystrix-For" class="headerlink" title="What Is Hystrix For?"></a>What Is Hystrix For?</h2><p>Hystrix is designed to do the following:</p>
<ul>
<li>Give protection from and control over latency and failure from dependencies accessed (typically over the network) via third-party client libraries.   让程序具有处理调用外部服务失败的能力</li>
<li>Stop cascading failures in a complex distributed system.</li>
<li>Fail fast and rapidly recover.</li>
<li>Fallback and gracefully degrade when possible.</li>
<li>Enable near real-time monitoring, alerting, and operational control.<h2 id="Hystrix-works-by"><a href="#Hystrix-works-by" class="headerlink" title="Hystrix works by:"></a>Hystrix works by:</h2></li>
<li>Preventing any single dependency from using up all container (such as Tomcat) user threads.</li>
<li>Shedding load and failing fast instead of queueing.</li>
<li>Providing fallbacks wherever feasible to protect users from failure.</li>
<li>Using isolation techniques (such as bulkhead, swimlane, and circuit breaker patterns) to limit the impact of any one dependency.</li>
<li>Optimizing for time-to-discovery through near real-time metrics, monitoring, and alerting</li>
<li>Optimizing for time-to-recovery by means of low latency propagation of configuration changes and support for dynamic property changes in most aspects of Hystrix, which allows you to make real-time operational modifications with low latency feedback loops.</li>
<li>Protecting against failures in the entire dependency client execution, not just in the network traffic.</li>
</ul>
<p>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>下面是一个HystrixCommand的简单的“hello world”实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandHelloWorld</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a real example would do work like a network call here</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###同步执行<br>Hystrix commands能通过execute()方法调用被同步的执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).execute();</span><br></pre></td></tr></table></figure></p>
<p>###异步执行<br>异步执行通过调用queue()方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; fs = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).queue();</span><br></pre></td></tr></table></figure></p>
<p>###响应式执行<br>响应式执行（异步回调）通过使用observe() 执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; fs = <span class="keyword">new</span> CommandHelloWorld(<span class="string">"World"</span>).observe();</span><br></pre></td></tr></table></figure></p>
<p>返回值可以通过订阅Observable获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// value emitted here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>优美的降级可以通过增加一个getFallback()实现来达到。该方法在各种类型的失败后执行。如： run（）方<br>法调用失败，超时，线程池，信号丢弃以及熔断器短路。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello Failure "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><p>从run（）方法中抛出的所以异常(除了HystrixBadRequestException)都被计为异常。将触发getFallback()<br>和熔断逻辑。在HystrixBadRequestException中抛出的例外，你可以根据你的喜好进行包装，然后通过<br>getCause()获取。<br>HystrixBadRequestException设计的使用场景为，报告不合法的参数或非系统性错误。这些都不能计入失<br>败次数的度量，也不应当触发回退逻辑</p>
<h2 id="Command-Name"><a href="#Command-Name" class="headerlink" title="Command Name"></a>Command Name</h2><h2 id="Command-Group"><a href="#Command-Group" class="headerlink" title="Command Group"></a>Command Group</h2><p>group进行统一管理<br>command组键名被用于将command分组，如报表，警告，面板或者组包的所以者。<br>默认情况下，它被用于command的线程池的命名，除非有单独的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Setter cachedSetter = </span><br><span class="line">        Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"HelloWorld"</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cachedSetter);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Command线程池"><a href="#Command线程池" class="headerlink" title="Command线程池"></a>Command线程池</h2><p>线程池的键被用于监控HystrixThreadPool时的呈现，度量的发布，缓存等其它应用。一个<br>HystrixCommand 是和一个单个的HystrixThreadPool相关联，通过注入它的HystrixThreadPoolKey可以取<br>得HystrixThreadPool 或者它默认情况下用HystrixCommandGroupKey创建一个。</p>
<h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><p>请求缓存通过实现<figure class="highlight plain"><figcaption><span>```或者```HystrixObservableCommand```中的``` getCacheKey() ```方法完成：依赖于request context 的某些东西，必须实例化HystrixRequestContext</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">``` java</span><br><span class="line">public class CommandUsingRequestCache extends HystrixCommand&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    protected CommandUsingRequestCache(int value) &#123;</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;));</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean run() &#123;</span><br><span class="line">        return value == 0 || value % 2 == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getCacheKey() &#123;</span><br><span class="line">        return String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>请求合并是一个特性，它能自动将一批请求合并到单一的HystrixCommand实例中执行。<br>可以设定批次的大小和时间作为促发器来执行一个批次<br>两种style的请求合并</p>
<ul>
<li>request-scoped </li>
<li>globally-scoped.<br>This is configured at collapser construction, and defaulted to request-scoped.<h2 id="Request-Context-Setup"><a href="#Request-Context-Setup" class="headerlink" title="Request Context Setup"></a>Request Context Setup</h2>为了能使用request的scoped特性（请求缓存，请求折叠，请求日记）HystrixRequestContext 的生命周期<br>必须被管理起来。（或者一个替代的HystrixConcurrencyStrategy 实现）<br>这就意味着下面代码必须在一个请求之前执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在请求的最后调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.shutdown();</span><br></pre></td></tr></table></figure></p>
<h1 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h1><h2 id="快速失败-Fail-Fast"><a href="#快速失败-Fail-Fast" class="headerlink" title="快速失败 Fail Fast"></a>快速失败 Fail Fast</h2><h2 id="无声失败-Fail-Silent"><a href="#无声失败-Fail-Silent" class="headerlink" title="无声失败 Fail Silent"></a>无声失败 Fail Silent</h2><p>无声的失败等同于返回一个空的响应或者删除功能,它通过返回null，空的map对象，空的list或者其他类似<br>的响应实现。 通常通过HystrixCommand实例中的getFallback() 方法实现</p>
<h2 id="回退：静态的-Fallback-Static"><a href="#回退：静态的-Fallback-Static" class="headerlink" title="回退：静态的 Fallback:Static"></a>回退：静态的 Fallback:Static</h2><p>一些回退能返回在代码中硬编码的值。它不能引起特性或将被移除服务（如同无声失败经常处理的方<br>法），但是执行默认的行为逻辑。</p>
<h2 id="Fallback-Stubbed"><a href="#Fallback-Stubbed" class="headerlink" title="Fallback: Stubbed"></a>Fallback: Stubbed</h2><p>一个存根回退典型的被用于包含多个字段的一个组合对象被返回时。它们其中的一部分能被其它请求状态<br>来决定。当其它字段被设置为默认值。</p>
<h2 id="Fallback-Cache-via-Network"><a href="#Fallback-Cache-via-Network" class="headerlink" title="Fallback: Cache via Network"></a>Fallback: Cache via Network</h2><p>由于回退如果重掉网络可能导致另外的失败，因此需要通过另外的HystrixCommand转换。<br>另外重要的是，回退command应当在独立的线程池中执行。如果两个command共享相同的线程池，会导<br>致主command将变的延迟并且占用整个的线程池，从而阻止回退。</p>
<h2 id="主从都失效"><a href="#主从都失效" class="headerlink" title="主从都失效"></a>主从都失效</h2><p><img src="https://github.com/Netflix/Hystrix/wiki/images/primary-secondary-example-640.png" alt="enter image description here"><br>通过两个Command进行隔离</p>
<p>##Client Doesn’t Perform Network Access</p>
<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p><img src="https://github.com/Netflix/Hystrix/wiki/images/library-migration-to-hystrix-without-640.png" alt="enter image description here"><br>to<br><img src="https://github.com/Netflix/Hystrix/wiki/images/library-migration-to-hystrix-with-640.png" alt="enter image description here"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://slamke.github.io/2015/02/03/动态分区说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sun Ke">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雁渡寒潭 风吹疏竹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/03/动态分区说明/" itemprop="url">动态分区说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-03T17:32:12+08:00">
                2015-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hive/" itemprop="url" rel="index">
                    <span itemprop="name">Hive</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/02/03/动态分区说明/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/02/03/动态分区说明/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hive分区"><a href="#Hive分区" class="headerlink" title="Hive分区"></a>Hive分区</h1><p><a href="http://lxw1234.com/archives/2015/06/286.htm" target="_blank" rel="noopener">Hive的动态分区</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>hive中支持两种类型的分区：</p>
<ul>
<li>静态分区SP（static partition）</li>
<li>动态分区DP（dynamic partition）</li>
</ul>
<p>静态分区与动态分区的主要区别在于静态分区是手动指定，而动态分区是通过数据来进行判断。详细来说，静态分区的列实在编译时期，通过用户传递来决定的；动态分区只有在SQL执行时才能决定。</p>
<h2 id="动态分区说明"><a href="#动态分区说明" class="headerlink" title="动态分区说明"></a>动态分区说明</h2><p>关系型数据库（如Oracle）中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>按照常规的方法向分区表中插入数据，如果源数据量很大，那么针对一个分区就要写一个insert，非常麻烦，你必须先要知道源数据中都有什么样的数据才能创建分区。<br>例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert overwrite table partition_test partition(stat_date='20110728',province='henan') select member_id,name from partition_test_input where stat_date='20110728' and province='henan';</span><br></pre></td></tr></table></figure></p>
<p>使用动态分区可以很好的解决上述问题。动态分区可以根据查询得到的数据自动匹配到相应的分区中去。<br>使用动态分区要先设置hive.exec.dynamic.partition参数值为true，默认值为false，即不允许使用：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; set hive.exec.dynamic.partition;</span><br><span class="line">hive.exec.dynamic.partition=false</span><br><span class="line">hive&gt; set hive.exec.dynamic.partition=true;</span><br><span class="line">hive&gt; set hive.exec.dynamic.partition;</span><br><span class="line">hive.exec.dynamic.partition=true</span><br></pre></td></tr></table></figure></p>
<p>动态分区的使用方法很简单，假设我想向stat_date=’20110728’这个分区下面插入数据，至于province插入到哪个子分区下面让数据库自己来判断，那可以这样写：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert overwrite table partition_test partition(stat_date='20110728',province)</span><br><span class="line">&gt; select member_id,name,province from partition_test_input where stat_date='20110728';</span><br><span class="line">Total MapReduce jobs = 2</span><br><span class="line">...</span><br><span class="line">3 Rows loaded to partition_test</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>stat_date叫做<strong>静态分区列</strong>，province叫做<strong>动态分区列</strong>。select子句中需要把动态分区列按照分区的顺序写出来，静态分区列不用写出来。这样stat_date=’20110728’的所有数据，会根据province的不同分别插入到/user/hive/warehouse/partition_test/stat_date=20110728/下面的不同的子文件夹下，如果源数据对应的province子分区不存在，则会自动创建，非常方便，而且避免了人工控制插入数据与分区的映射关系存在的潜在风险。</p>
<ul>
<li>注意，动态分区不允许主分区采用动态列而副分区采用静态列，这样将导致所有的主分区都要创建副分区静态列所定义的分区</li>
<li>动态分区可以允许所有的分区列都是动态分区列，但是要首先设置一个参数hive.exec.dynamic.partition.mode ：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; set hive.exec.dynamic.partition.mode;</span><br><span class="line">hive.exec.dynamic.partition.mode=strict</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="动态分区demo"><a href="#动态分区demo" class="headerlink" title="动态分区demo"></a>动态分区demo</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> hive.exec.dynamic.partition=<span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">SET</span> hive.exec.dynamic.partition.mode=nonstrict; </span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions.pernode = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SET</span> hive.exec.max.dynamic.partitions=<span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> t_lxw1234_partitioned <span class="keyword">PARTITION</span> (<span class="keyword">month</span>,<span class="keyword">day</span>) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span>,<span class="keyword">substr</span>(<span class="keyword">day</span>,<span class="number">1</span>,<span class="number">7</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,<span class="keyword">day</span> </span><br><span class="line"><span class="keyword">FROM</span> t_lxw1234;</span><br></pre></td></tr></table></figure>
<h2 id="动态分区参数"><a href="#动态分区参数" class="headerlink" title="动态分区参数"></a>动态分区参数</h2><p>使用动态分区需要注意设定以下参数：</p>
<ul>
<li><p>hive.exec.dynamic.partition<br>默认值：false<br>是否开启动态分区功能，默认false关闭。<br>使用动态分区时候，该参数必须设置成true;</p>
</li>
<li><p>hive.exec.dynamic.partition.mode<br>默认值：strict<br>动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。<br>一般需要设置为nonstrict</p>
</li>
<li><p>hive.exec.max.dynamic.partitions.pernode<br>默认值：100<br>在每个执行MR的节点上，最大可以创建多少个动态分区。<br>该参数需要根据实际的数据来设定。<br>比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p>
</li>
<li><p>hive.exec.max.dynamic.partitions<br>默认值：1000<br>在所有执行MR的节点上，最大一共可以创建多少个动态分区。<br>同上参数解释。</p>
</li>
<li><p>hive.exec.max.created.files<br>默认值：100000<br>整个MR Job中，最大可以创建多少个HDFS文件。<br>一般默认值足够了，除非你的数据量非常大，需要创建的文件数大于100000，可根据实际情况加以调整。</p>
</li>
<li><p>hive.error.on.empty.partition<br>默认值：false<br>当有空分区生成时，是否抛出异常。<br>一般不需要设置。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sun Ke</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">104</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Ke</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Sunke.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
