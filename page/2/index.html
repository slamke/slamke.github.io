
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>雁渡寒潭 风吹疏竹</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Sun Ke">
    

    
    <meta name="description" content="人生不止眼前的苟且">
<meta property="og:type" content="website">
<meta property="og:title" content="雁渡寒潭 风吹疏竹">
<meta property="og:url" content="slamke.github.io/page/2/index.html">
<meta property="og:site_name" content="雁渡寒潭 风吹疏竹">
<meta property="og:description" content="人生不止眼前的苟且">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雁渡寒潭 风吹疏竹">
<meta name="twitter:description" content="人生不止眼前的苟且">

    
    <link rel="alternative" href="/atom.xml" title="雁渡寒潭 风吹疏竹" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="雁渡寒潭 风吹疏竹" title="雁渡寒潭 风吹疏竹"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="雁渡寒潭 风吹疏竹">雁渡寒潭 风吹疏竹</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:slamke.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/16/Yarn的基本结构和工作原理/" title="Yarn的基本结构和工作原理" itemprop="url">Yarn的基本结构和工作原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2018-01-16T08:00:33.000Z" itemprop="datePublished"> Published 2018-01-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="1-YARN-基本架构"><a href="#1-YARN-基本架构" class="headerlink" title="1.YARN 基本架构"></a>1.YARN 基本架构</h1><p>YARN是Hadoop 2.0中的资源管理系统，它的基本设计思想是将MRv1中的<strong>JobTracker</strong>拆分成了两个独立的服务：一个全局的资源管理器 <strong>ResourceManager</strong>和每个应用程序特有的<strong>ApplicationMaster</strong>。其中ResourceManager负责整个系统的资源管理和分配，而ApplicationMaster负责单个应用程序的管理。</p>
<h2 id="1-1-YARN基本组成结构"><a href="#1-1-YARN基本组成结构" class="headerlink" title="1.1 YARN基本组成结构"></a>1.1 YARN基本组成结构</h2><p>YARN总体上仍然是Master/Slave结构，在整个资源管理框架中，<strong>ResourceManager为Master</strong>，<strong>NodeManager为Slave</strong>，<strong>ResourceManager负责对各个NodeManager上的资源进行统一管理和调度</strong>。当用 户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManger启动可以占用一定资源的任务。由于不同的ApplicationMaster被分布到不同的节点上，因此它们之间不会相互影响。</p>
<p>下图描述了YARN的基本组成结构，YARN主要由ResourceManager、NodeManager、 ApplicationMaster和Container等几个组件构成。</p>
<p><img src="https://github.com/slamke/image/blob/master/hadoop/yarn/yarn-artitechure.png?raw=true" alt=""></p>
<ol>
<li><code>ResourceManager</code>（RM）</li>
</ol>
<p>RM是一个全局的资源管理器，负责整个系统的资源管理和分配。它主要由两个组件构成：调度器（<code>Scheduler</code>）和应用程序管理器（<code>Applications Manager，ASM</code>）。</p>
<p>（1） 调度器 调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。需要注意的是， 该调度器是一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪应用的执行状态等，也不负责重新启动因应用执行失败或者硬 件故障而产生的失败任务，这些均交由应用程序相关的ApplicationMaster完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分 配单位用一个抽象概念“资源容器”（Resource Container，简称Container）表示，Container是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限 定每个任务使用的资源量。此外，该调度器是一个可插拔的组件，用户可根据自己的需要设计新的调度器，YARN提供了多种直接可用的调度器，比如<code>Fair Scheduler</code>和<code>Capacity Scheduler</code>等。</p>
<p>（2） 应用程序管理器应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动它等。</p>
<ol>
<li>ApplicationMaster（AM） </li>
</ol>
<p>用户提交的每个应用程序均包含一个AM，主要功能包括：</p>
<p>①与RM调度器协商以获取资源（用Container表示）；</p>
<p>②将得到的任务进一步分配给内部的任务；</p>
<p>③与NM通信以启动/停止任务；</p>
<p>④监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。</p>
<p>当前YARN自带了两个AM实现，一个是用于演示AM编写方法的实例程序distributedshell，它可以申请一定数目的Container以并 行运行一个Shell命令或者Shell脚本；另一个是运行MapReduce应用程序的AM—MRAppMaster。此外，一些其他的计算框架对应的 AM正在开发中，比如Open MPI、Spark等。</p>
<ol>
<li>NodeManager（NM） </li>
</ol>
<p>NM是每个节点上的资源和任务管理器，一方面，它会定时地向RM汇报本节点上的资源使用情况和各个Container的运行状态；另一方面，它接收并处理来自AM的Container启动/停止等各种请求。</p>
<ol>
<li>Container   </li>
</ol>
<p>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的 资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。需要注意的 是，Container不同于MRv1中的slot，它是一个动态资源划分单位，是根据应用程序的需求动态生成的。截至本书完成时，YARN仅支持CPU 和内存两种资源，且使用了轻量级资源隔离机制Cgroups进行资源隔离。</p>
<h1 id="2-Yarn的工作流程"><a href="#2-Yarn的工作流程" class="headerlink" title="2.Yarn的工作流程"></a>2.Yarn的工作流程</h1><p>运行在YARN上的应用程序主要分为两类：短应用程序和长应用程序，其中，短应用程序是指一定时间内（可能是秒级、分钟级或小时级，尽管天级别或者更长时 间的也存在，但非常少）可运行完成并正常退出的应用程序，比如MapReduce作业、Tez DAG作业等，长应用程序是指不出意外，永不终止运行的应用程序，通常是一些服务，比如Storm Service（主要包括Nimbus和Supervisor两类服务），HBase Service（包括Hmaster和RegionServer两类服务）等，而它们本身作为一个框架提供了编程接口供用户使用。尽管这两类应用程序作用 不同，一类直接运行数据处理程序，一类用于部署服务（服务之上再运行数据处理程序），但运行在YARN上的流程是相同的。</p>
<p>当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序：</p>
<p>第一个阶段是启动ApplicationMaster；</p>
<p>第二个阶段是由ApplicationMaster创建应用程序，为它申请资源，并监控它的整个运行过程，直到运行完成。如下图所示，YARN的工作流程分为以下几个步骤：</p>
<p><strong><em><img src="https://github.com/slamke/image/blob/master/hadoop/yarn/yarn-message.jpg?raw=true" alt=""></em></strong></p>
<p>步骤1　用户向YARN中提交应用程序，其中包括ApplicationMaster程序、启动ApplicationMaster的命令、用户程序等。</p>
<p>步骤2　ResourceManager为该应用程序分配第一个Container，并与对应的Node-Manager通信，要求它在这个Container中启动应用程序的ApplicationMaster。</p>
<p>步骤3　ApplicationMaster首先向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即重复步骤4~7。</p>
<p>步骤4　ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</p>
<p>步骤5　一旦ApplicationMaster申请到资源后，便与对应的NodeManager通信，要求它启动任务。</p>
<p>步骤6　NodeManager为任务设置好运行环境（包括环境变量、JAR包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务。</p>
<p>步骤7　各个任务通过某个RPC协议向ApplicationMaster汇报自己的状态和进度，以让ApplicationMaster随时掌握各个任务 的运行状态，从而可以在任务失败时重新启动任务。在应用程序运行过程中，用户可随时通过RPC向  ApplicationMaster查询应用程序的当前运行状态。</p>
<p>步骤8　应用程序运行完成后，ApplicationMaster向ResourceManager注销并关闭自己。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Hadoop/">Hadoop</a><a href="/tags/Yarn/">Yarn</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/09/Livy/" title="Livy" itemprop="url">Livy</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2018-01-09T08:34:39.000Z" itemprop="datePublished"> Published 2018-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="http://geek.csdn.net/news/detail/208943" target="_blank" rel="external">Livy：基于Apache Spark的REST服务</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/09/数据库与数据仓库的本质区别是什么/" title="数据库与数据仓库的本质区别是什么" itemprop="url">数据库与数据仓库的本质区别是什么</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2018-01-09T07:33:35.000Z" itemprop="datePublished"> Published 2018-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>整理自知乎： <a href="https://www.zhihu.com/question/20623931" target="_blank" rel="external">https://www.zhihu.com/question/20623931</a></p>
<h2 id="逻辑层面-概念层面"><a href="#逻辑层面-概念层面" class="headerlink" title="逻辑层面/概念层面"></a>逻辑层面/概念层面</h2><p>数据库和数据仓库其实是一样的或者及其相似的，都是通过某个数据库软件，基于某种数据模型来组织、管理数据。</p>
<p>数据库通常更关注业务交易处理（OLTP），而数据仓库更关注数据分析层面（OLAP），由此产生的数据库模型上也会有很大的差异。数据库通常追求交易的速度，交易完整性，数据的一致性，等等，在数据库模型上主要遵从范式模型（1NF，2NF，3NF，等等），从而尽可能减少数据冗余，保证引用完整性；而数据仓库强调数据分析的效率，复杂查询的速度，数据之间的相关性分析，所以在数据库模型上，数据仓库喜欢使用多维模型，从而提高数据分析的效率。</p>
<p>数据库：传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</p>
<p>数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
<p>举个最常见的例子，拿电商行业来说好了。基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。</p>
<ul>
<li>电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。</li>
<li>第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成多台服务器和多个业务数据库（量大+分库分表），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。</li>
<li>第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到非常精细化和具体的用户的集群分析，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。</li>
</ul>
<p>这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：</p>
<ul>
<li>业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。</li>
<li>业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>
</ul>
<p>而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：</p>
<ul>
<li>数据结构为了分析和查询的便利；</li>
<li>只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</li>
</ul>
<p>那么在这里前一种业务数据库（读写都优化）的是业务性数据库，后一种是分析性数据库，即数据仓库。</p>
<p>最后总结一下：数据库 比较流行的有：MySQL, Oracle, SqlServer等数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等这样把数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的 ETL 工作。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据仓库/">数据仓库</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数据仓库/">数据仓库</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/09/SpringBoot/" title="SpringBoot" itemprop="url">SpringBoot</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2018-01-09T07:28:54.000Z" itemprop="datePublished"> Published 2018-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="https://mp.weixin.qq.com/s/9Wmm2N24-cdRitodO34bWA" target="_blank" rel="external">这一篇文章带你感受微服务的生和死，Spring Boot是生和死的主旋律</a></p>
<p>内容: 给出了微服务的一些概念文章，还有SpringBoot相关的文章</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spring/">Spring</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spring/">Spring</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/05/Python知识点/" title="Python知识点" itemprop="url">Python知识点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2018-01-05T03:03:26.000Z" itemprop="datePublished"> Published 2018-01-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-sys-path-append-添加模块至模块扫描路径"><a href="#1-sys-path-append-添加模块至模块扫描路径" class="headerlink" title="1. sys.path.append() 添加模块至模块扫描路径"></a>1. sys.path.append() 添加模块至模块扫描路径</h2><p>当我们导入一个模块时：import  xxx，默认情况下python解析器会搜索当前目录、已安装的内置模块和第三方模块，搜索路径存放在sys模块的path中：<br>sys.path 返回的是一个列表！<br>该路径已经添加到系统的环境变量了，当我们要添加自己的搜索目录时，可以通过列表的append()方法；</p>
<p>对于模块和自己写的脚本不在同一个目录下，在脚本开头加sys.path.append(‘xxx’)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line">sys.path.append(’引用模块的地址<span class="string">')</span></span><br></pre></td></tr></table></figure>
<p>这种方法是运行时修改，脚本运行后就会失效的。</p>
<p>另外一种方法是：</p>
<p>把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。</p>
<p>sys模块包含了与python解释器和它的环境有关的函数，这个你可以通过dir(sys)来查看他里面的方法和成员属性。<br>下面的两个方法可以将模块路径加到当前模块扫描的路径里：<br>sys.path.append(‘你的模块的名称’)。<br>sys.path.insert(0,’模块的名称’)<br>永久添加路径到sys.path中，方式有三，如下：<br>1）将写好的py文件放到 已经添加到系统环境变量的 目录下 ；<br>2) 在 /usr/lib/python2.6/site-packages 下面新建一个.pth 文件(以pth作为后缀名)<br>将模块的路径写进去，一行一个路径，如： vim pythonmodule.pth<br>/home/liu/shell/config<br>/home/liu/shell/base<br>3) 使用PYTHONPATH环境变量<br>export PYTHONPATH=$PYTHONPATH:/home/liu/shell/config</p>
<h2 id="2-Python-ConfigParser模块常用方法示例"><a href="#2-Python-ConfigParser模块常用方法示例" class="headerlink" title="2. Python ConfigParser模块常用方法示例"></a>2. Python ConfigParser模块常用方法示例</h2><p>在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在Python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。  </p>
<p>Python ConfigParser模块解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[db]    </span><br><span class="line">db_host=192.168.1.1   </span><br><span class="line">db_port=3306   </span><br><span class="line">db_user=root   </span><br><span class="line">db_pass=password   </span><br><span class="line">[concurrent]    </span><br><span class="line">thread=200   </span><br><span class="line">processor=400</span><br><span class="line">```   </span><br><span class="line">假设上面的配置文件的名字为test.conf。里面包含两个section,一个是db, 另一个是concurrent, db里面还包含有4项，concurrent里面有两项。这里来做做解析：  </span><br><span class="line">``` python</span><br><span class="line">#-*- encoding: gb2312 -*-    </span><br><span class="line">import ConfigParser,string,os,sys    </span><br><span class="line">cf = ConfigParser.ConfigParser()    </span><br><span class="line">cf.read(&quot;test.conf&quot;)   </span><br><span class="line">  </span><br><span class="line"># 返回所有的section    </span><br><span class="line">s = cf.sections()    </span><br><span class="line">print &apos;section:&apos;, s    </span><br><span class="line">o = cf.options(&quot;db&quot;)    </span><br><span class="line">print &apos;options:&apos;, o    </span><br><span class="line">v = cf.items(&quot;db&quot;)    </span><br><span class="line">print &apos;db:&apos;, v    </span><br><span class="line">print &apos;-&apos;*60    </span><br><span class="line">  </span><br><span class="line">#可以按照类型读取出来  </span><br><span class="line">db_host = cf.get(&quot;db&quot;, &quot;db_host&quot;)    </span><br><span class="line">db_port = cf.getint(&quot;db&quot;, &quot;db_port&quot;)    </span><br><span class="line">db_user = cf.get(&quot;db&quot;, &quot;db_user&quot;)    </span><br><span class="line">db_pass = cf.get(&quot;db&quot;, &quot;db_pass&quot;)   </span><br><span class="line">  </span><br><span class="line"># 返回的是整型的    </span><br><span class="line">threads = cf.getint(&quot;concurrent&quot;, &quot;thread&quot;)    </span><br><span class="line">processors = cf.getint(&quot;concurrent&quot;, &quot;processor&quot;)    </span><br><span class="line">print &quot;db_host:&quot;, db_host    </span><br><span class="line">print &quot;db_port:&quot;, db_port    </span><br><span class="line">print &quot;db_user:&quot;, db_user    </span><br><span class="line">print &quot;db_pass:&quot;, db_pass    </span><br><span class="line">print &quot;thread:&quot;, threads    </span><br><span class="line">print &quot;processor:&quot;, processors   </span><br><span class="line">  </span><br><span class="line">#修改一个值，再写回去    </span><br><span class="line">cf.set(&quot;db&quot;, &quot;db_pass&quot;, &quot;zhaowei&quot;)    </span><br><span class="line">cf.write(open(&quot;test.conf&quot;, &quot;w&quot;))   </span><br><span class="line">  </span><br><span class="line">#添加一个section。（同样要写回）  </span><br><span class="line">cf.add_section(&apos;liuqing&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;int&apos;, &apos;15&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;bool&apos;, &apos;true&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;float&apos;, &apos;3.1415&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;baz&apos;, &apos;fun&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;bar&apos;, &apos;Python&apos;)  </span><br><span class="line">cf.set(&apos;liuqing&apos;, &apos;foo&apos;, &apos;%(bar)s is %(baz)s!&apos;)  </span><br><span class="line">cf.write(open(&quot;test.conf&quot;, &quot;w&quot;))  </span><br><span class="line">  </span><br><span class="line">#移除section 或者option 。（只要进行了修改就要写回的哦）  </span><br><span class="line">cf.remove_option(&apos;liuqing&apos;,&apos;int&apos;)  </span><br><span class="line">cf.remove_section(&apos;liuqing&apos;)  </span><br><span class="line">cf.write(open(&quot;test.conf&quot;, &quot;w&quot;))</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Decorator-的本质"><a href="#3-Decorator-的本质" class="headerlink" title="3. Decorator 的本质"></a>3. Decorator 的本质</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hello, %s"</span> % fn.__name__</span><br><span class="line">        fn()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"goodby, %s"</span> % fn.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@hello</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i am foo"</span></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>返回:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello, foo</span><br><span class="line">i am foo</span><br><span class="line">goodby, foo</span><br></pre></td></tr></table></figure></p>
<p>对于Python的这个@注解语法糖- Syntactic Sugar 来说，当你在用某个@decorator来修饰某个函数func时，如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>其解释器会解释成下面这样的语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure></p>
<p>尼玛，这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的，但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的func。<br>根据《函数式编程》中的first class functions中的定义的，你可以把函数当成变量来使用，所以，decorator必需得返回了一个函数出来给func，这就是所谓的higher order function 高阶函数，不然，后面当func()调用的时候就会出错。 就我们上面那个hello.py里的例子来说，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@hello</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i am foo"</span></span><br></pre></td></tr></table></figure></p>
<p>被解释成了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">foo = hello(foo)</span><br><span class="line">``` </span><br><span class="line">### class式的 Decorator</span><br><span class="line">首先，先得说一下，decorator的class方式，还是看个示例：</span><br><span class="line">``` python </span><br><span class="line">class myDecorator(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self, fn):</span><br><span class="line">        print "inside myDecorator.__init__()"</span><br><span class="line">        self.fn = fn</span><br><span class="line"> </span><br><span class="line">    def __call__(self):</span><br><span class="line">        self.fn()</span><br><span class="line">        print "inside myDecorator.__call__()"</span><br><span class="line"> </span><br><span class="line">@myDecorator</span><br><span class="line">def aFunction():</span><br><span class="line">    print "inside aFunction()"</span><br><span class="line"> </span><br><span class="line">print "Finished decorating aFunction()"</span><br><span class="line"> </span><br><span class="line">aFunction()</span><br><span class="line"> </span><br><span class="line"># 输出：</span><br><span class="line"># inside myDecorator.__init__()</span><br><span class="line"># Finished decorating aFunction()</span><br><span class="line"># inside aFunction()</span><br><span class="line"># inside myDecorator.__call__()</span><br></pre></td></tr></table></figure></p>
<h3 id="一些decorator的示例"><a href="#一些decorator的示例" class="headerlink" title="一些decorator的示例"></a>一些decorator的示例</h3><h4 id="给函数调用做缓存"><a href="#给函数调用做缓存" class="headerlink" title="给函数调用做缓存"></a>给函数调用做缓存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(fn)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    miss = object()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = cache.get(args, miss)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> miss:</span><br><span class="line">            result = fn(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，是一个斐波拉契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。</p>
<p>而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。</p>
<h4 id="注册回调函数"><a href="#注册回调函数" class="headerlink" title="注册回调函数"></a>注册回调函数</h4><p>下面这个示例展示了通过URL的路由来调用相关注册的函数示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func_map = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            self.func_map[name] = func</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line">        <span class="keyword">return</span> func_wrapper</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_method</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        func = self.func_map.get(name, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"No function registered against - "</span> + str(name))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"> </span><br><span class="line">app = MyApp()</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.register('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_page_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is the main page."</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.register('/next_page')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_page_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is the next page."</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> app.call_method(<span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">print</span> app.call_method(<span class="string">'/next_page'</span>)</span><br></pre></td></tr></table></figure>
<p>注意：<br>1）上面这个示例中，用类的实例来做decorator。<br>2）decorator类中没有<strong>call</strong>()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。</p>
<h4 id="线程异步"><a href="#线程异步" class="headerlink" title="线程异步"></a>线程异步</h4><p>下面量个非常简单的异步执行的decorator，注意，异步处理并不简单，下面只是一个示例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func_hl = Thread(target = func, args = args, kwargs = kwargs)</span><br><span class="line">        func_hl.start()</span><br><span class="line">        <span class="keyword">return</span> func_hl</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> async_func</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @async</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_somedata</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'starting print_somedata'</span></span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'print_somedata: 2 sec passed'</span></span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'print_somedata: 2 sec passed'</span></span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'finished print_somedata'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print_somedata()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'back in main'</span></span><br><span class="line">        print_somedata()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'back in main'</span></span><br><span class="line"> </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h2 id="4-Python的getattr-setattr-delattr-hasattr"><a href="#4-Python的getattr-setattr-delattr-hasattr" class="headerlink" title="4.Python的getattr(),setattr(),delattr(),hasattr()"></a>4.Python的getattr(),setattr(),delattr(),hasattr()</h2><h3 id="获取对象引用getattr"><a href="#获取对象引用getattr" class="headerlink" title="获取对象引用getattr"></a>获取对象引用getattr</h3><p>getattr()函数是Python自省的核心函数，具体使用大体如下：</p>
<p>Getattr用于返回一个对象属性，或者方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A:   </span><br><span class="line">    def __init__(self):   </span><br><span class="line">        self.name = 'zhangjing'  </span><br><span class="line">　　  #self.age='24'</span><br><span class="line">    def method(self):   </span><br><span class="line">        print"method print"  </span><br><span class="line">  </span><br><span class="line">Instance = A()   </span><br><span class="line">print getattr(Instance , 'name, 'not find') #如果Instance 对象中有属性name则打印self.name的值，否则打印'not find'</span><br><span class="line">print getattr(Instance , 'age', 'not find')   #如果Instance 对象中有属性age则打印self.age的值，否则打印'not find'</span><br><span class="line">print getattr(a, 'method', 'default')   </span><br><span class="line">#如果有方法method，否则打印其地址，否则打印default   </span><br><span class="line">print getattr(a, 'method', 'default')()   </span><br><span class="line">#如果有方法method，运行函数并打印None否则打印default</span><br></pre></td></tr></table></figure>
<p>注：使用getattr可以轻松实现工厂模式。<br>例：一个模块支持html、text、xml等格式的打印，根据传入的formate参数的不同，调用不同的函数实现几种格式的输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsout   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(data, format=<span class="string">"text"</span>)</span>:</span>                                </span><br><span class="line">     output_function = getattr(statsout, <span class="string">"output_%s"</span> % format)   </span><br><span class="line">    <span class="keyword">return</span> output_function(data)</span><br></pre></td></tr></table></figure>
<h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr"></a>setattr</h3><p>这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar = 123。</p>
<h3 id="delattr"><a href="#delattr" class="headerlink" title="delattr"></a>delattr</h3><p>与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, ‘foobar’)=del x.foobar</p>
<h3 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr"></a>hasattr</h3><p>hasattr用于确定一个对象是否具有某个属性。</p>
<p>语法：<br> hasattr(object, name) -&gt; bool<br>判断object中是否有name属性，返回一个布尔值。</p>
<h2 id="5-使用-property"><a href="#5-使用-property" class="headerlink" title="5. 使用@property"></a>5. 使用@property</h2><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">9999</span></span><br></pre></td></tr></table></figure></p>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure></p>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure></p>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">``` python </span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure></p>
<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">``` python </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<p>注意到这个神奇的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</span><br><span class="line">``` python </span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2014 - self._birth</span><br></pre></td></tr></table></figure></p>
<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</p>
<p>###小结</p>
<p><strong>@property</strong>广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h2 id="6-Python-中的-classmethod-和-staticmethod-有什么具体用途？"><a href="#6-Python-中的-classmethod-和-staticmethod-有什么具体用途？" class="headerlink" title="6. Python 中的 classmethod 和 staticmethod 有什么具体用途？"></a>6. Python 中的 classmethod 和 staticmethod 有什么具体用途？</h2><p>@classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.</p>
<p>@staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Kls(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">    def printd(self):</span><br><span class="line">        print(self.data)</span><br><span class="line">    @staticmethod</span><br><span class="line">    def smethod(*arg):</span><br><span class="line">        print('Static:', arg)</span><br><span class="line">    @classmethod</span><br><span class="line">    def cmethod(*arg):</span><br><span class="line">        print('Class:', arg)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; ik = Kls(23)</span><br><span class="line">&gt;&gt;&gt; ik.printd()</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; ik.smethod()</span><br><span class="line">Static: ()</span><br><span class="line">&gt;&gt;&gt; ik.cmethod()</span><br><span class="line">Class: (&lt;class '__main__.Kls'&gt;,)</span><br><span class="line">&gt;&gt;&gt; Kls.printd()</span><br><span class="line">TypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)</span><br><span class="line">&gt;&gt;&gt; Kls.smethod()</span><br><span class="line">Static: ()</span><br><span class="line">&gt;&gt;&gt; Kls.cmethod()</span><br><span class="line">Class: (&lt;class '__main__.Kls'&gt;,)</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Python/">Python</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Python/">Python</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/12/Spark写GBK文件/" title="Spark写GBK文件" itemprop="url">Spark写GBK文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-12-12T02:18:25.000Z" itemprop="datePublished"> Published 2017-12-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result: <span class="type">RDD</span>[(<span class="type">NullWritable</span>, <span class="type">Text</span>)] = totalData.map &#123;</span><br><span class="line">        item =&gt;</span><br><span class="line">          <span class="keyword">val</span> line = <span class="string">s"<span class="subst">$&#123;item.query&#125;</span>"</span></span><br><span class="line">          (<span class="type">NullWritable</span>.get(), <span class="keyword">new</span> <span class="type">Text</span>(line.getBytes(<span class="string">"GBK"</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置输出格式，以GBK存储</span></span><br><span class="line">      result.saveAsNewAPIHadoopFile(path, classOf[<span class="type">NullWritable</span>],</span><br><span class="line">        classOf[<span class="type">Text</span>], classOf[<span class="type">TextOutputFormat</span>[<span class="type">NullWritable</span>, <span class="type">Text</span>]])</span><br></pre></td></tr></table></figure>
<p>参考:</p>
<p><a href="http://lxw1234.com/archives/2015/07/404.htm" target="_blank" rel="external">RDD行动Action操作(6)–saveAsHadoopFile</a></p>
<p><a href="https://www.iteblog.com/archives/1281.html" target="_blank" rel="external">Spark多文件输出(MultipleOutputFormat)</a></p>
<p><a href="https://www.iteblog.com/archives/842.html" target="_blank" rel="external">Hadoop多文件输出：MultipleOutputFormat和MultipleOutputs深究(一)</a></p>
<p><a href="https://www.iteblog.com/archives/848.html" target="_blank" rel="external">Hadoop多文件输出：MultipleOutputFormat和MultipleOutputs深究(二)</a></p>
<p><a href="http://blog.csdn.net/zklth/article/details/11829563" target="_blank" rel="external">Hadoop 中文编码相关问题 – mapreduce程序处理GBK编码数据并输出GBK编码数据</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a><a href="/tags/GBK/">GBK</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/05/如何有效地记录JavaSQL日志/" title="如何有效地记录JavaSQL日志" itemprop="url">如何有效地记录JavaSQL日志</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-12-05T02:55:49.000Z" itemprop="datePublished"> Published 2017-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>参考： <a href="http://blog.oneapm.com/apm-tech/178.html" target="_blank" rel="external">http://blog.oneapm.com/apm-tech/178.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/SQL/">SQL</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/05/JUnit测试中文乱码问题解决/" title="JUnit测试中文乱码问题解决" itemprop="url">JUnit测试中文乱码问题解决</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-12-05T02:37:05.000Z" itemprop="datePublished"> Published 2017-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>pom.xml中添加plugin： 指定测试时的编码类型<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">forkMode</span>&gt;</span>once<span class="tag">&lt;/<span class="name">forkMode</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">argLine</span>&gt;</span>-Dfile.encoding=UTF-8<span class="tag">&lt;/<span class="name">argLine</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考： <a href="http://yong3773.iteye.com/blog/1971454" target="_blank" rel="external">http://yong3773.iteye.com/blog/1971454</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/Junit/">Junit</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/30/Spark写Redis实践总结/" title="Spark写Redis实践总结" itemprop="url">Spark写Redis实践总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-10-30T03:42:52.000Z" itemprop="datePublished"> Published 2017-10-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="http://bourneli.github.io/scala/spark/pit/2017/10/27/spark-to-redis.html" target="_blank" rel="external">Spark写Redis实践总结</a></p>
<p>Redis是一个高性能键值数据库，最近几年非常流行。笔者所在的团队也在大规模的使用Redis作为后台数据存储解决方案。Redis作为机器学习算法与后台服务器的媒介，算法计算用户数据并写入Redis；后台服务器读取Redis，并为前端提供实时接口。本文主要介绍Spark写如Redis的实践，同时记录一些坑，方便后面回顾。</p>
<p>笔者使用Spark 2.0的scala API，使用jedis客户端API，dependency如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>写Redis的代码如下<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 写Redis</span></span><br><span class="line">sampleData.repartition(<span class="number">500</span>).foreachPartition(rows =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> rc = <span class="keyword">new</span> <span class="type">Jedis</span>(redisHost, redisPort)</span><br><span class="line">  rc.auth(redisPassword)</span><br><span class="line">  <span class="keyword">val</span> pipe = rc.pipelined</span><br><span class="line"></span><br><span class="line">  rows.foreach(r =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> redisKey = r.getAs[<span class="type">String</span>](<span class="string">"key"</span>)</span><br><span class="line">    <span class="keyword">val</span> redisValue = r.getAs[<span class="type">String</span>](<span class="string">"value"</span>)</span><br><span class="line">    pipe.set(redisKey, redisValue)</span><br><span class="line">    pipe.expire(redisKey, expireDays * <span class="number">3600</span> * <span class="number">24</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  pipe.sync()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>实践1：控制客户端对象数量</p>
<p>sampleData是一个DataSet，每一行有两个数据：key和value。由于构建Jedis客户端会有一定开销，所以一定不要用map，而是mapPartition或foreachPartition。这样，这个开销只会与parition数量相关，与数据总量无关。试想如果sampleData有1亿行，在map中将会构建1亿个Jedis对象。</p>
<p>实践2：批量插入数据</p>
<p>笔者使用了pipe进行批量插入，而不是逐条插入，批量插入效率与逐条插入效率差异参考这里。但是批量插入有个非常大的坑。上面的代码中，一次性批量插入了整个partition的数据，所以如果单个partition的数据量太多，会导致Redis内存溢出，导致服务不可用！</p>
<p>解决方法是在foreachPartition之前，repartition整个DateSet，确保每个分区的数据不要太大。推荐控制在1千左右。正如上面的列子，笔者将sampleData分为500个分区，每个分区1000条，那么sampleData的总数为50万左右。但是，如果数据总量太大，单个分区过小，会导致分区数过大，这样需要提高driver的内存，否则会导致driver内存溢出。</p>
<p>实践3：控制在线更新并发</p>
<p>Redis一般提供在线服务，在更新Redis的同时，它可能在前端提供服务。所以在写Redis时，不能使用太多executor。否则会使得QPS过高，影响在线服务响应，甚至导致Redis瘫痪。推荐的实践方法是提高数据的分区数量，确保每个partition的数量较小，然后逐步提高并发数量（executor数量）。观察在不同数量executor下，并发写入Redis的QPS，直到QPS达到一个可以接受的范围。</p>
<p>进一步改进</p>
<p>上述方案在5千万行数据，每行value小于100Byte的情况下，在我们的redis环境，写入时qps稳定在15000左右，不影响线上服务。这个方案被woliwang同学质疑，主要观点是如果数据量达到亿，十亿级别，如果还是设置每个partition 1000个数据量，会有上百万个partition，容易导致driver OOM。的确，上面的方案还有改进空间，可以对每个partition进一步分组，比将partition控制在10万数据量，然后每次批量写入1000数据，按顺序写100次 就可以写完，这样driver就不需要维护上百万的partition信息，同时也可以控制写入速率。</p>
<p>最后</p>
<p>实践是检验真理的唯一标准。上面的几点实践在不同Redis集群下，具体数值可能不一样，但原理不变。希望这些总结对你有用。如果自己想搭建spark+Redis环境，推荐VPS供应商Vultr，无需购买服务器，随时随地可用，物美价廉。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Spark/">Spark</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spark/">Spark</a><a href="/tags/Redis/">Redis</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/12/基于用户投票的排名算法/" title="基于用户投票的排名算法" itemprop="url">基于用户投票的排名算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Sun Ke" target="_blank" itemprop="author">Sun Ke</a>
		
  <p class="article-time">
    <time datetime="2017-10-12T10:02:33.000Z" itemprop="datePublished"> Published 2017-10-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><a href="http://www.ruanyifeng.com/blog/2012/02/ranking_algorithm_hacker_news.html" target="_blank" rel="external">基于用户投票的排名算法（一）：Delicious和Hacker News</a><br><a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_reddit.html" target="_blank" rel="external">基于用户投票的排名算法（二）：Reddit</a><br><a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_stack_overflow.html" target="_blank" rel="external">基于用户投票的排名算法（三）：Stack Overflow</a><br><a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_newton_s_law_of_cooling.html" target="_blank" rel="external">基于用户投票的排名算法（四）：牛顿冷却定律</a></p>
<p>对信息进行排名，意味着将信息按照重要性依次排列，并且及时进行更新。排列的依据，可以基于信息本身的特征，也可以基于用户的投票，即让用户决定，什么样的信息可以排在第一位。<br>根据用户的投票，决定最近一段时间内的”热文排名”。</p>
<p>最直觉、最简单的算法，莫过于按照单位时间内用户的投票数进行排名。得票最多的项目，自然就排在第一位。这个算法的优点是比较简单、容易部署、内容更新相当快；缺点是，一方面，排名变化不够平滑，前一个小时还排名靠前的内容，往往第二个小时就一落千丈，另一方面，缺乏自动淘汰旧项目的机制，某些热门内容可能会长期占据排行榜前列。<br>所以根据得票数，系统自动统计出热门文章排行榜。但是，并非得票最多的文章排在第一位，还要考虑时间因素，新文章应该比旧文章更容易得到好的排名。</p>
<p>公式： <figure class="highlight plain"><figcaption><span>= （P-1）/(T+2)^G ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中，　　P表示帖子的得票数，减去1是为了忽略发帖人的投票。 　　T表示距离发帖的时间（单位为小时），加上2是为了防止最新的帖子导致分母过小（之所以选择2，可能是因为从原始文章出现在其他网站，到转贴至Hacker News，平均需要两个小时）。　　G表示&quot;重力因子&quot;（gravityth power），即将帖子排名往下拉的力量，默认值为1.8，后文会详细讨论这个值。</span><br><span class="line"></span><br><span class="line">从这个公式来看，决定帖子排名有三个因素：</span><br><span class="line">第一个因素是得票数P。</span><br><span class="line">在其他条件不变的情况下，得票越多，排名越高。 如果你不想让&quot;高票帖子&quot;与&quot;低票帖子&quot;的差距过大，可以在得票数上加一个小于1的指数，比如(P-1)^0.8。</span><br><span class="line">第二个因素是距离发帖的时间T。</span><br><span class="line">在其他条件不变的情况下，越是新发表的帖子，排名越高。或者说，一个帖子的排名，会随着时间不断下降。</span><br><span class="line">第三个因素是重力因子G。</span><br><span class="line">它的数值大小决定了排名随时间下降的速度。G值越大，曲线越陡峭，排名下降得越快，意味着排行榜的更新速度越快。</span><br><span class="line"></span><br><span class="line">## 所有时段的排名</span><br><span class="line"></span><br><span class="line">[基于用户投票的排名算法（五）：威尔逊区间](http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_wilson_score_interval.html)</span><br><span class="line"></span><br><span class="line">一种常见的错误算法是： 　```　得分 = 赞成票 - 反对票</span><br></pre></td></tr></table></figure></p>
<p>假定有两个项目，项目A是60张赞成票，40张反对票，项目B是550张赞成票，450张反对票。请问，谁应该排在前面？按照上面的公式，B会排在前面，因为它的得分（550 - 450 = 100）高于A（60 - 40 = 20）。但是实际上，B的好评率只有55%（550 / 1000），而A为60%（60 / 100），所以正确的结果应该是A排在前面。<br>另一种常见的错误算法是: <code>得分 = 赞成票 / 总票数</code> 如果”总票数”很大，这种算法其实是对的。问题出在如果”总票数”很少，这时就会出错。假定A有2张赞成票、0张反对票，B有100张赞成票、1张反对票。这种算法会使得A排在B前面。这显然错误。</p>
<p>我们先做如下设定：<br>　　（1）每个用户的投票都是独立事件。<br>　　（2）用户只有两个选择，要么投赞成票，要么投反对票。<br>　　（3）如果投票总人数为n，其中赞成票为k，那么赞成票的比例p就等于k/n。<br>如果你熟悉统计学，可能已经看出来了，这是一种统计分布，叫做”二项分布”（binomial distribution）。这很重要，下面马上要用到。<br>们的思路是，p越大，就代表这个项目的好评比例越高，越应该排在前面。但是，p的可信性，取决于有多少人投票，如果样本太小，p就不可信。好在我们已经知道，p是”二项分布”中某个事件的发生概率，因此我们可以计算出p的置信区间。所谓”置信区间”，就是说，以某个概率而言，p会落在的那个区间。比如，某个产品的好评率是80%，但是这个值不一定可信。根据统计学，我们只能说，有95%的把握可以断定，好评率在75%到85%之间，即置信区间是[75%, 85%]。<br>这样一来，排名算法就比较清晰了：<br>　　第一步，计算每个项目的”好评率”（即赞成票的比例）。<br>　　第二步，计算每个”好评率”的置信区间（以95%的概率）。<br>　　第三步，根据置信区间的下限值，进行排名。这个值越大，排名就越高。</p>
<p>置信区间的实质，就是进行可信度的修正，弥补样本量过小的影响。如果样本多，就说明比较可信，不需要很大的修正，所以置信区间会比较窄，下限值会比较大；如果样本少，就说明不一定可信，必须进行较大的修正，所以置信区间会比较宽，下限值会比较小。</p>
<p>二项分布的置信区间有多种计算公式，最常见的是”正态区间”（Normal approximation interval），教科书里几乎都是这种方法。但是，它只适用于样本较多的情况（np &gt; 5 且 n(1 − p) &gt; 5），对于小样本，它的准确性很差。<br>1927年，美国数学家 Edwin Bidwell Wilson提出了一个修正公式，被称为”威尔逊区间”，很好地解决了小样本的准确性问题。</p>
<h2 id="贝叶斯平均"><a href="#贝叶斯平均" class="headerlink" title="贝叶斯平均"></a>贝叶斯平均</h2><p><a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_bayesian_average.html" target="_blank" rel="external">基于用户投票的排名算法（六）：贝叶斯平均</a></p>
<p>介绍了”威尔逊区间”，它解决了投票人数过少、导致结果不可信的问题。<br>举例来说，如果只有2个人投票，”威尔逊区间”的下限值会将赞成票的比例大幅拉低。这样做固然保证了排名的可信性，但也带来了另一个问题：排行榜前列总是那些票数最多的项目，新项目或者冷门的项目，很难有出头机会，排名可能会长期靠后。</p>
<p>在排名页面的底部，IMDB给出了它的计算方法。<code>WR = v/(v+m)  * R + m/(v+m) *C</code> </p>
<ul>
<li>WR， 加权得分（weighted rating）。</li>
<li>R，该电影的用户投票的平均得分（Rating）。</li>
<li>v，该电影的投票人数（votes）。</li>
<li>m，排名前250名的电影的最低投票数（现在为3000）。</li>
<li>C， 所有电影的平均得分（现在为6.9）。</li>
</ul>
<p>这种算法被称为”贝叶斯平均”（Bayesian average）。因为某种程度上，它借鉴了”贝叶斯推断”（Bayesian inference）的思想：既然不知道投票结果，那就先估计一个值，然后不断用新的信息修正，使得它越来越接近正确的值。<br>在这个公式中，m（总体平均分）是”先验概率”，每一次新的投票都是一个调整因子，使总体平均分不断向该项目的真实投票结果靠近。投票人数越多，该项目的”贝叶斯平均”就越接近算术平均，对排名的影响就越小。因此，这种方法可以给一些投票人数较少的项目，以相对公平的排名。<br>“贝叶斯平均”也有缺点，主要问题是它假设用户的投票是正态分布。比如，电影A有10个观众评分，5个为五星，5个为一星；电影B也有10个观众评分，都给了三星。这两部电影的平均得分（无论是算术平均，还是贝叶斯平均）都是三星，但是电影A可能比电影B更值得看。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/排名/">排名</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="slamke" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Akka/" title="Akka">Akka<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/HDFS/" title="HDFS">HDFS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hive/" title="Hive">Hive<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/Kafka/" title="Kafka">Kafka<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/ML/" title="ML">ML<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/REST/" title="REST">REST<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reactor/" title="Reactor">Reactor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Scala/" title="Scala">Scala<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spark/" title="Spark">Spark<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web/" title="Web">Web<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/多线程/" title="多线程">多线程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据仓库/" title="数据仓库">数据仓库<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/重构/" title="重构">重构<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Spark/" title="Spark">Spark<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Akka/" title="Akka">Akka<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Hive/" title="Hive">Hive<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Scala/" title="Scala">Scala<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Yarn/" title="Yarn">Yarn<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Session/" title="Session">Session<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Cookie/" title="Cookie">Cookie<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Spark-Streaming/" title="Spark Streaming">Spark Streaming<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Junit/" title="Junit">Junit<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UDF/" title="UDF">UDF<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/REST/" title="REST">REST<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Spark2-0/" title="Spark2.0">Spark2.0<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/HDFS/" title="HDFS">HDFS<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://slamke.blogspot.com/" target="_blank" title="我的博客">我的博客</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/slamke" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:sunke3296@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Sun Ke">Sun Ke</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
